# Set the directory we want to store zinit and plugins
ZINIT_HOME="${XDG_DATA_HOME:-${HOME}/.local/share}/zinit/zinit.git"

# Download Zinit, if it's not there yet
if [ ! -d "$ZINIT_HOME" ]; then
   mkdir -p "$(dirname $ZINIT_HOME)"
   git clone https://github.com/zdharma-continuum/zinit.git "$ZINIT_HOME"
fi

# Source/Load zinit
source "${ZINIT_HOME}/zinit.zsh"

#Add in Oh-my-posh
zinit ice depth=1; zinit light jandedobbeleer/oh-my-posh

# Add in zsh plugins
zinit light zsh-users/zsh-syntax-highlighting
zinit light zsh-users/zsh-completions
zinit light zsh-users/zsh-autosuggestions
zinit light Aloxaf/fzf-tab

# Add in snippets
zinit snippet OMZP::git
zinit snippet OMZP::sudo
zinit snippet OMZP::archlinux
zinit snippet OMZP::aws
zinit snippet OMZP::kubectl
zinit snippet OMZP::kubectx
zinit snippet OMZP::command-not-found
zinit snippet OMZP::dotenv
zinit snippet OMZP::rake
zinit snippet OMZP::rbenv
zinit snippet OMZP::ruby
#zinit snippet OMZP::adb
zinit snippet OMZP::python
zinit snippet OMZP::rust
zinit snippet OMZP::rvm
zinit snippet OMZP::ssh
zinit snippet OMZP::svn
zinit snippet OMZP::thefuck
zinit snippet OMZP::tmux
zinit snippet OMZP::tldr
zinit snippet OMZP::sdk
zinit snippet OMZP::zoxide
#zinit snippet OMZP::zsh-navigation-tools
#zinit snippet OMZP::ufw

# Load completions
autoload -Uz compinit && compinit

zinit cdreplay -q

# History
HISTSIZE=5000
HISTFILE=$HOME/.zsh_history
SAVEHIST=$HISTSIZE
HISTDUP=erase
setopt appendhistory
setopt sharehistory
setopt hist_ignore_space
setopt hist_ignore_all_dups
setopt hist_save_no_dups
setopt hist_ignore_dups
setopt hist_find_no_dups

# Completion styling
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Za-z}'
zstyle ':completion:*' list-colors "${(s.:.)LS_COLORS}"
zstyle ':completion:*' menu no
zstyle ':fzf-tab:complete:cd:*' fzf-preview 'ls --color $realpath'
zstyle ':fzf-tab:complete:__zoxide_z:*' fzf-preview 'ls --color $realpath'

# Shell integrations
eval "$(fzf --zsh)"
eval "$(zoxide init --cmd cd zsh)"

# Keybindings
bindkey -e
bindkey '^p' history-search-backward
bindkey '^n' history-search-forward
bindkey '^[w' kill-region

# Common Keybindings
bindkey "^[[H" beginning-of-line # Home key
bindkey "^[[F" end-of-line # End key
bindkey "^[[P" delete-char # Del key
bindkey "^[[A" history-beginning-search-backward # Up Arrow
bindkey "^[[B" history-beginning-search-forward # Down Arrow
bindkey "^[[1;5C" forward-word # Control + Right Arrow
bindkey "^[[1;5D" backward-word # Control + Left Arrow
bindkey "^H" backward-kill-word # Control + Backspace
bindkey "^[[M" kill-word # Control + Delete
bindkey "^[[7~" beginning-of-line # Home key
bindkey "^[[8~" end-of-line # End key
bindkey "^[[3~" delete-char # Del key
bindkey "^[Oc" forward-word # Control + Right Arrow
bindkey "^[Od" backward-word # Control + Left Arrow
bindkey "^[[3^" kill-word # Control + Delete

# Additional Keybindings
bindkey "^R" history-incremental-pattern-search-backward
bindkey "^S" history-incremental-pattern-search-forward

# Aliases
alias reboot='sudo reboot +0'
alias shutdown='sudo shutdown +0'
alias h="cat $HOME/.zsh_history | grep "
alias ezrc='nano $HOME/.zshrc'
alias hlp='cat $HOME/zshrc_aliases.md'
alias vi='nvim'
alias svi='sudo vi'
alias vis='nvim "+set si"'
alias vim='nvim'
alias c='clear'
alias cp='cp -iv --reflink=auto'
alias rcp='rsync -v --progress'
alias rmv='rsync -v --progress --remove-source-files'
alias mv='mv -iv'
alias less='less -R'
alias ln='ln -v'
alias chmod='chmod -c'
alias chown='chown -c'
alias mkdir='mkdir -v'
alias grep='grep --colour=auto'
#alias egrep='grep -E --colour=auto'
alias pbcopy='xclip -selection clipboard'
alias pbpaste='xclip -selection clipboard -o'
alias ls='eza'
alias ll='eza -alh'
alias tree='eza --tree'
alias clear-pacman-cache='sudo pacman -Sc'
alias clear-cache='yay -Sc'
#alias passwdGEN='python3 $HOME/Github/fun007/Passwd_Generator/passwd_gen.py -c -n -s 19 | grep "Generated Password:" | awk "{print \$3}" | tee >(pbcopy)'
alias rm='rm -f'
alias rmd='rm -rf'
alias ping='ping -c 10'
alias x='exit'
alias multitail='multitail --no-repeat -c'
alias freshclam='sudo freshclam'
alias alert='notify-send --urgency=low -i "$([ $? = 0 ] && printf terminal || printf error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'
alias da='date "+%Y-%m-%d %A %T %Z"'
alias genSRCINFO='makepkg --printsrcinfo > .SRCINFO'
alias kc='khal calendar'
alias yayf="yay -Slq | fzf --multi --preview 'yay -Sii {1}' --preview-window=down:75% | xargs -ro yay -S"

# Passwd Generator
passwdGEN() {
    local length=${1:-19}  # Default length: 19
    local case_variance=""
    local numbers=""
    local special=""

    # Only shift if there are arguments beyond the first one
    if [ $# -gt 1 ]; then
        shift  # Remove length argument
    elif [ $# -eq 1 ]; then
        # If only one argument (length), clear the argument list
        set --
    fi

    # Parse additional arguments for character set flags
    while [ $# -gt 0 ]; do
        case "$1" in
            -c|--case-variance) case_variance="-c" ;;
            -n|--numbers) numbers="-n" ;;
            -s|--special) special="-s" ;;
            *) echo "Error: Invalid option $1. Use -c, -n, or -s." ; return 1 ;;
        esac
        shift
    done

    # Validate length
    if ! [[ "$length" =~ ^[0-9]+$ ]] || [ "$length" -lt 12 ]; then
        echo "Error: Length must be a number >= 12"
        return 1
    fi

    # Check if at least one character set is enabled (script requires at least lowercase)
    if [ -z "$case_variance" ] && [ -z "$numbers" ] && [ -z "$special" ]; then
        echo "Warning: No character sets specified. Defaulting to lowercase + uppercase + numbers + special."
        case_variance="-c"
        numbers="-n"
        special="-s"
    fi

    # Run the password generator and extract the password
    python3 $HOME/Github/fun007/Passwd_Generator/passwd_gen.py $case_variance $numbers $special "$length" | grep "Generated Password:" | awk '{for(i=3;i<=NF;i++)printf "%s", $i}' | tee >(pbcopy)
    echo  # Add newline after password
}

# fastfetch utils
alias ff='fastfetch'

ff-upd() {
    cd $HOME/fastfetch || return

    output=$(git pull)

    # Check if the output indicates "Already up to date."
    if [[ $output == *"Already up to date."* ]]; then
        printf "Fastfetch is already up to date. No need to rebuild.\n"
        cd
    else
        cd $HOME/fastfetch/build || return

        # Remove all contents in the build directory
        rm -rf *

        # Rebuild and install Fastfetch
        cmake .. && cmake --build . --target package && sudo cmake --install . --prefix /usr/

        cd
    fi
}


# egrep error escape logic
egrep() {
  grep -E --colour=auto "$@" 2>/dev/null
}

# Change directory aliases
alias home='cd $HOME'
alias cd..='cd ..'
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'

# alias chmod commands
alias mx='chmod a+x'
alias 000='chmod -R 000'
alias 644='chmod -R 644'
alias 666='chmod -R 666'
alias 755='chmod -R 755'
alias 777='chmod -R 777'



if command -v bat > /dev/null; then
     alias cat="bat"
elif command -v batcat > /dev/null; then
     alias cat="batcat"
fi

if command -v colordiff > /dev/null 2>&1; then
    alias diff="colordiff -Nuar"
else
    alias diff="diff -Nuar"
fi

# Alias's for archives
alias mktar='tar -cvf'
alias mkbz2='tar -cvjf'
alias mkgz='tar -cvzf'
alias untar='tar -xvf'
alias unbz2='tar -xvjf'
alias ungz='tar -xvzf'
alias mk7z='7z a -t7z'
alias mkzip='zip -r'

# Extracts any archive(s) (if unp isn't installed)
extract() {
    for archive in "$@"; do
        if [ -f "$archive" ]; then
            case $archive in
            *.tar.bz2) tar xvjf $archive ;;
            *.tar.gz) tar xvzf $archive ;;
            *.tar.xz) tar xvJf $archive ;;
            *.bz2) bunzip2 $archive ;;
            *.rar) unrar x $archive ;;
            *.gz) gunzip $archive ;;
            *.tar) tar xvf $archive ;;
            *.tbz2) tar xvjf $archive ;;
            *.tgz) tar xvzf $archive ;;
            *.zip) unzip $archive ;;
            *.Z) uncompress $archive ;;
            *.7z) 7z x $archive ;;
            *.xz) unxz $archive ;;
            *) printf "don't know how to extract '%s'...\n" "$archive" ;;
            esac
        else
            printf "'%s' is not a valid file!\n" "$archive"
        fi
    done
}

# Automated encryption and decryption on file/folders
mkcryptgz() {
    if [[ -d "$1" ]]; then
        tarball="${1}.tar.gz"
        tar -czf "$tarball" "$1" && gpg --output "${tarball}.gpg" --symmetric "$tarball" && rm "$tarball"
        if [[ $? -eq 0 ]]; then
            printf "Directory '%s' compressed, encrypted, and original archive removed.\n" "$1"
        else
            printf "Error during compression or encryption.\n"
        fi
    else
        printf "'%s' is not a valid directory!\n" "$1"
    fi
}

ungpgextract() {
    if [[ -f "$1" ]]; then
        output_file="${1%.gpg}"
        gpg --output "$output_file" --decrypt "$1"

        if [[ $? -eq 0 ]]; then
            extract "$output_file"
            if [[ $? -eq 0 ]]; then
                rm "$output_file"
                printf "Decrypted, extracted, and removed: %s\n" "$output_file"
            else
                printf "Extraction failed.\n"
            fi
        else
            printf "Decryption failed.\n"
        fi
    else
        printf "'%s' is not a valid file!\n" "$1"
    fi
}


# Searches for text in all files in the current folder
ftext() {
    # -i case-insensitive
    # -I ignore binary files
    # -H causes filename to be printed
    # -r recursive search
    # -n causes line number to be printed
    # optional: -F treat search term as a literal, not a regular expression
    # optional: -l only print filenames and not the matching lines ex. grep -irl "$1" *
    grep -iIHrn --color=always "$1" . | less -r
}


# Finds and adds fastest mirror lists for pacman
httpsmirrors() {
    temp_mirrorlist=$(mktemp)  # Correctly create a temporary file

    # Generate the new mirrorlist
    rate-mirrors --allow-root --protocol https arch | awk "/^# FINISHED AT:/ {p=1} p" > "$temp_mirrorlist"

    # Check if the output is non-empty
    if [ -s "$temp_mirrorlist" ]; then
        # Attempt to update the mirrorlist with sudo
        if sudo tee /etc/pacman.d/mirrorlist < "$temp_mirrorlist" > /dev/null; then
            printf "Mirrorlist updated successfully.\n"
        else
            printf "Failed to update mirrorlist due to sudo error.\n"
        fi
    else
        printf "Failed to generate new mirrorlist. Retaining the previous list.\n"
    fi

    rm -f "$temp_mirrorlist"  # Always remove the temporary file
}

# Alias to show all established connections and their resolved names
alias show_connections='sudo netstat -tupn | grep "ESTABLISHED" | awk '\''{print $5}'\'' | cut -d: -f1 | sort | uniq | xargs -I {} sh -c '\''printf "%s: " "{}"; nslookup {}'\'' | grep "name ="'

# Alias to show the external NAT'ed IP
alias external_ip='IP=$(curl -s https://api.ipify.org) && printf "This is your External IP address %s.\n" "$IP"'

# Alias to show the installation date of the system
install_date() {
  install_date=$(sudo btrfs subvolume show / | grep "Creation time" | awk -F": " '{print $2}' | xargs)
  printf "Your Arch Linux OS was installed on %s.\n" "$install_date"
}

# Alias to show the last reboot time of the system
alias last_reboot='FQDN=$(uname -n); hostname=$(printf "%s" "$FQDN" | cut -d. -f1); last_reboot=$(date -d @$(( $(date +%s) - $(awk '\''{print int($1)}'\'' /proc/uptime) ))); printf "The %s system was last rebooted on %s.\n" "$hostname" "$last_reboot"'

# Alias to try out your new theme using color scripts from the Color-Scripts repository
alias random_color_script='COLOR_SCRIPT_REPO=https://api.github.com/repos/stark/Color-Scripts/contents/color-scripts; wget -q -O - $(curl -s $COLOR_SCRIPT_REPO | jq ".[] | \"\(.path) \(.download_url)\"" -r | shuf -n1 | cut -d " " -f2) | bash'

# Alias for quick access to weather
alias opwttr='$HOME/DWM/scripts/OpWeatherinfo'

# IP address lookup
alias whatismyip="whatsmyip"
function whatsmyip ()
{
    # Internal IP Lookup.
    if [ -e /usr/bin/ip ]; then
        printf "Internal IP: "
        /usr/bin/ip addr show wlp0s20f3 | grep "inet " | awk -F: '{print $1}' | awk '{print $2}'
    else
        printf "Internal IP: "
        /usr/bin/ifconfig wlp0s20f3 | grep "inet " | awk -F: '{print $1} |' | awk '{print $2}'
    fi

    # External IP Lookup
    printf "External IP: "
    printf "%s\n" "$(curl -s ifconfig.me)"
}

# Search running processes
alias p="ps aux | grep "
alias topcpu="/bin/ps -eo pcpu,pid,user,args | sort -k 1 -r | head -10"

# Search files in the current folder
alias f="find . | grep "

# Count all files (recursively) in the current folder
alias countfiles="for t in files links directories; do printf \"%s %s\n\" \"\$(find . -type \${t:0:1} | wc -l)\" \"\$t\"; done 2> /dev/null"

# To see if a command is aliased, a file, or a built-in command
alias checkcommand="type -t"

# Show open ports
alias openports='netstat -nape --inet'

# Alias's to show disk space and space used in a folder
alias diskspace="du -S | sort -n -r |more"
alias folders='du -h --max-depth=1'
alias folderssort='find . -maxdepth 1 -type d -print0 | xargs -0 du -sk | sort -rn'
alias treed='tree -CAFd'
alias mountedinfo='df -hT'

# Show all logs in /var/log
alias logs="sudo find /var/log -type f -exec file {} \; | grep 'text' | cut -d' ' -f1 | sed -e's/:$//g' | grep -v '[0-9]$' | xargs sudo tail -f"

# SHA1
alias sha1='openssl sha1'

alias clickpaste='sleep 3; xdotool type "$(xclip -o -selection clipboard)"'

# KITTY - alias to be able to use kitty features when connecting to remote servers(e.g use tmux on remote server)
alias kssh="kitty +kitten ssh"

# QP var chooser
filter_papers() {
  local file=$1
  local keep_qp=$2

  awk '!/"$keep_qp"'[1-9]/ "$file" > filtered_results.dat
}

# Copy file with a progress bar
cpp() {
    set -e
    strace -q -ewrite cp -- "${1}" "${2}" 2>&1 |
        awk '{
    count += $NF
    if (count % 10 == 0) {
        percent = count / total_size * 100
        printf "%3d%% [", percent
        for (i=0;i<=percent;i++)
            printf "="
            printf ">"
            for (i=percent;i<100;i++)
                printf " "
                printf "]\r"
            }
        }
    END { printf "\n" }' total_size="$(stat -c '%s' "${1}")" count=0
}

# Copy and go to the directory
cpg() {
    if [ -d "$2" ]; then
        cp "$1" "$2" && cd "$2"
    else
        cp "$1" "$2"
    fi
}

# Move and go to the directory
mvg() {
    if [ -d "$2" ]; then
        mv "$1" "$2" && cd "$2"
    else
        mv "$1" "$2"
    fi
}

# Create and go to the directory
mkdirg() {
    mkdir -p "$1"
    cd "$1"
}

# Goes up a specified number of directories  (i.e. up 4)
up() {
    local d=""
    limit=$1
    for ((i = 1; i <= limit; i++)); do
        d=$d/..
    done
    d=$(printf "%s" "$d" | sed 's/^\///')
    if [ -z "$d" ]; then
        d=..
    fi
    cd $d
}

# Returns the last 2 fields of the working directory
pwdtail() {
    pwd | awk -F/ '{nlast = NF -1;print $nlast"/"$NF}'
}

# Show the current distribution
distribution ()
{
    local dtype="unknown"  # Default to unknown

    # Use /etc/os-release for modern distro identification
    if [ -r /etc/os-release ]; then
        source /etc/os-release
        case $ID in
            fedora|rhel|centos)
                dtype="redhat"
                ;;
            sles|opensuse*)
                dtype="suse"
                ;;
            ubuntu|debian)
                dtype="debian"
                ;;
            gentoo)
                dtype="gentoo"
                ;;
            arch)
                dtype="arch"
                ;;
            slackware)
                dtype="slackware"
                ;;
            *)
                # If ID is not recognized, keep dtype as unknown
                ;;
        esac
    fi

    printf "%s\n" "$dtype"
}

# Show the current version of the operating system
ver() {
    local dtype
    dtype=$(distribution)

    case $dtype in
        "redhat")
            if [ -s /etc/redhat-release ]; then
                cat /etc/redhat-release
            else
                cat /etc/issue
            fi
            uname -a
            ;;
        "suse")
            cat /etc/SuSE-release
            ;;
        "debian")
            lsb_release -a
            ;;
        "gentoo")
            cat /etc/gentoo-release
            ;;
        "arch")
            cat /etc/os-release
            ;;
        "slackware")
            cat /etc/slackware-version
            ;;
        *)
            if [ -s /etc/issue ]; then
                cat /etc/issue
            else
                printf "Error: Unknown distribution\n"
                exit 1
            fi
            ;;
    esac
}

# View Apache logs
apachelog() {
    if [ -f /etc/httpd/conf/httpd.conf ]; then
        cd /var/log/httpd && ls -xAh && multitail --no-repeat -c -s 2 /var/log/httpd/*_log
    else
        cd /var/log/apache2 && ls -xAh && multitail --no-repeat -c -s 2 /var/log/apache2/*.log
    fi
}

# Edit the Apache configuration
apacheconfig() {
    if [ -f /etc/httpd/conf/httpd.conf ]; then
        nano /etc/httpd/conf/httpd.conf
    elif [ -f /etc/apache2/apache2.conf ]; then
        nano /etc/apache2/apache2.conf
    else
        printf "Error: Apache config file could not be found.\n"
        printf "Searching for possible locations:\n"
        sudo updatedb && locate httpd.conf && locate apache2.conf
    fi
}

# Edit the PHP configuration file
phpconfig() {
    if [ -f /etc/php.ini ]; then
        nano /etc/php.ini
    elif [ -f /etc/php/php.ini ]; then
        nano /etc/php/php.ini
    elif [ -f /etc/php5/php.ini ]; then
        nano /etc/php5/php.ini
    elif [ -f /usr/bin/php5/bin/php.ini ]; then
        nano /usr/bin/php5/bin/php.ini
    elif [ -f /etc/php5/apache2/php.ini ]; then
        nano /etc/php5/apache2/php.ini
    else
        printf "Error: php.ini file could not be found.\n"
        printf "Searching for possible locations:\n"
        sudo updatedb && locate php.ini
    fi
}

# Edit the MySQL configuration file
mysqlconfig() {
    if [ -f /etc/my.cnf ]; then
        nano /etc/my.cnf
    elif [ -f /etc/mysql/my.cnf ]; then
        nano /etc/mysql/my.cnf
    elif [ -f /usr/local/etc/my.cnf ]; then
        nano /usr/local/etc/my.cnf
    elif [ -f /usr/bin/mysql/my.cnf ]; then
        nano /usr/bin/mysql/my.cnf
    elif [ -f $HOME/my.cnf ]; then
        nano $HOME/my.cnf
    elif [ -f $HOME/.my.cnf ]; then
        nano $HOME/.my.cnf
    else
        printf "Error: my.cnf file could not be found.\n"
        printf "Searching for possible locations:\n"
        sudo updatedb && locate my.cnf
    fi
}


# Trim leading and trailing spaces (for scripts)
trim() {
    local var=$*
    var="${var#"${var%%[![:space:]]*}"}" # remove leading whitespace characters
    var="${var%"${var##*[![:space:]]}"}" # remove trailing whitespace characters
    printf "%s" "$var"
}

# GitHub Additions

gcom() {
    git add .
    git commit -m "$1"
}

lazyg() {
    git pull --rebase
    git add .
    git commit -m "$1"
    git push
}

# Function to switch to Cloudflare DNS
cloudflare_dns() {
    printf "nameserver 1.1.1.2\nnameserver 1.0.0.2\n" | sudo tee /etc/resolv.conf > /dev/null
    printf "Switched to Cloudflare DNS\n"
}

# Function to switch to Quad9 DNS
quad9_dns() {
    printf "nameserver 9.9.9.11\nnameserver 149.112.112.11\n" | sudo tee /etc/resolv.conf > /dev/null
    printf "Switched to Quad9 DNS\n"
}

dwn_iso() {
    local iso_dir="$HOME/Downloads/ISO"
    mkdir -p "$iso_dir"

    # Arch Linux URLs (primary and fallback)
    local arch_url_base1="https://mirror.rackspace.com/archlinux/iso/latest/"
    local arch_url_base2="https://geo.mirror.pkgbuild.com/iso/latest/"

    # Tails base URL
    local tails_url_base="https://mirrors.edge.kernel.org/tails/stable/"

    # Function to download Arch Linux ISO
    download_arch_iso() {
        local arch_latest_ver=$(curl -sL "${arch_url_base1}" | grep -oP 'archlinux-\K[0-9]{4}\.[0-9]{2}\.[0-9]{2}' | head -n 1)
        local iso_filename="archlinux-${arch_latest_ver}-x86_64.iso"

        # Check if the ISO already exists
        if [ -f "$iso_dir/$iso_filename" ]; then
            echo "Arch ISO is already the latest version: $iso_filename"
        else
            # Download from primary and fallback if necessary
            if ! curl -o "$iso_dir/$iso_filename" "${arch_url_base1}${iso_filename}"; then
                echo "Primary Arch URL failed, attempting fallback..."
                curl -o "$iso_dir/$iso_filename" "${arch_url_base2}${iso_filename}"
            fi

            # Download the verification files
            curl -o "$iso_dir/sha256sums.txt" "${arch_url_base1}sha256sums.txt" || curl -o "$iso_dir/sha256sums.txt" "${arch_url_base2}sha256sums.txt"
            curl -o "$iso_dir/b2sums.txt" "${arch_url_base1}b2sums.txt" || curl -o "$iso_dir/b2sums.txt" "${arch_url_base2}b2sums.txt"
            curl -o "$iso_dir/${iso_filename}.sig" "${arch_url_base1}${iso_filename}.sig" || curl -o "$iso_dir/${iso_filename}.sig" "${arch_url_base2}${iso_filename}.sig"

            # Download and import Arch Linux signing keys if needed
            if ! gpg --list-keys 76A5EF9054449A5C &>/dev/null; then
                echo "Downloading Arch Linux signing key..."
                gpg --auto-key-locate clear,wkd -v --locate-external-key pierre@archlinux.org
            fi

            # Run ISO verification script
            sh "$iso_dir/iso_verifier.sh" "$iso_dir/$iso_filename"
        fi
    }

    # Function to download Tails ISO
    download_tails_iso() {
        local tails_latest_ver=$(curl -sL "${tails_url_base}" | grep -oP 'tails-amd64-\K[0-9]+\.[0-9]+(?=/)' | sort -V | tail -n 1)
        local iso_filename="tails-amd64-${tails_latest_ver}.iso"

        # Check if the ISO already exists
        if [ -f "$iso_dir/$iso_filename" ]; then
            echo "Tails ISO is already the latest version: $iso_filename"
        else
            # Download the ISO and .sig file
            curl -o "$iso_dir/$iso_filename" "${tails_url_base}tails-amd64-${tails_latest_ver}/$iso_filename"
            curl -o "$iso_dir/$iso_filename.sig" "${tails_url_base}tails-amd64-${tails_latest_ver}/$iso_filename.sig"

            # Run ISO verification script (only GPG signature)
            sh "$iso_dir/iso_verifier.sh" "$iso_dir/$iso_filename"
        fi
    }

    # Main logic
    echo "Checking for new Arch and Tails ISO versions..."

    download_arch_iso
    download_tails_iso
}

# FZF-based Anime Torrent Manager for .zshrc
# Download directory path - centralized for easy updating
ANIME_DOWNLOAD_DIR="$HOME/Videos"

# HTTP request helper function
fetch_url() {
    local url="$1"
    if command -v curl &> /dev/null; then
        curl -s "$url"
    elif command -v wget &> /dev/null; then
        wget -q -O - "$url"
    else
        echo "Error: curl or wget is required but not installed."
        return 1
    fi
}

# Function to calculate dynamic FZF height based on item count
_calculate_fzf_height() {
    local item_count="$1"
    local min_height=10
    local max_height=25
    local padding=4  # Extra lines for border, prompt, etc.

    local calculated_height=$((item_count + padding))

    # Ensure height is within bounds
    if [[ $calculated_height -lt $min_height ]]; then
        echo "${min_height}"
    elif [[ $calculated_height -gt $max_height ]]; then
        echo "${max_height}"
    else
        echo "${calculated_height}"
    fi
}

# Main FZF anime interface
anime() {
    # Check if fzf is installed
    if ! command -v fzf &> /dev/null; then
        echo "Error: fzf is required but not installed."
        echo "Install it with: brew install fzf (macOS) or apt install fzf (Ubuntu)"
        return 1
    fi

    while true; do
        local options="üîç Search Anime\nüì∫ Latest Releases\nüå∏ Seasonal Anime\n‚öôÔ∏è  Browse by Fansub\nüîÑ Setup RSS\n‚ùå Exit"
        local option_count=$(echo -e "$options" | wc -l)
        local height=$(_calculate_fzf_height $option_count)

        local choice=$(echo -e "$options" | fzf \
            --prompt="üéå Anime Manager ‚Ä∫ " \
            --height="${height}" \
            --border=rounded \
            --border-label=" Main Menu " \
            --border-label-pos=2 \
            --ansi \
            --cycle \
            --info=inline)

        case "$choice" in
            *"Search Anime"*)
                _anime_search_interface
                ;;
            *"Latest Releases"*)
                _anime_latest_interface
                ;;
            *"Seasonal Anime"*)
                _anime_seasonal_interface
                ;;
            *"Browse by Fansub"*)
                _anime_fansub_interface
                ;;
            *"Setup RSS"*)
                _anime_rss_interface
                ;;
            *"Exit"*|"")
                break
                ;;
        esac
    done
}

# Search interface with multiple selections
_anime_search_interface() {
    echo "Enter anime name to search:"
    read -r search_term

    if [[ -z "$search_term" ]]; then
        echo "No search term provided."
        return 1
    fi

    # Quality selection
    local quality_options="1080p\n720p\n480p\nAny Quality"
    local quality_count=$(echo -e "$quality_options" | wc -l)
    local quality_height=$(_calculate_fzf_height $quality_count)

    local quality=$(echo -e "$quality_options" | fzf \
        --prompt="üì∫ Quality ‚Ä∫ " \
        --height="${quality_height}" \
        --border=rounded \
        --border-label=" Select Quality " \
        --border-label-pos=2 \
        --cycle)
    [[ "$quality" == "Any Quality" ]] && quality=""

    # Fansub selection
    local fansub_options="All Fansubs\nSubsPlease\nErai-raws\nDameDesuYo\nHorribleSubs\nCommie\nAniplex"
    local fansub_count=$(echo -e "$fansub_options" | wc -l)
    local fansub_height=$(_calculate_fzf_height $fansub_count)

    local fansub=$(echo -e "$fansub_options" | fzf \
        --prompt="üë• Fansub ‚Ä∫ " \
        --height="${fansub_height}" \
        --border=rounded \
        --border-label=" Select Fansub Group " \
        --border-label-pos=2 \
        --cycle)
    [[ "$fansub" == "All Fansubs" ]] && fansub=""

    _anime_browse_and_download "$search_term" "$quality" "$fansub"
}

# Latest releases interface
_anime_latest_interface() {
    echo "üì∫ Fetching latest anime releases..."
    _anime_browse_and_download "" "1080p" ""
}

# Seasonal anime interface
_anime_seasonal_interface() {
    echo "üå∏ Fetching seasonal anime..."

    # Get current season
    local current_month=$(date +%m)
    local season=""

    if [[ $current_month -ge 1 && $current_month -le 3 ]]; then
        season="WINTER"
    elif [[ $current_month -ge 4 && $current_month -le 6 ]]; then
        season="SPRING"
    elif [[ $current_month -ge 7 && $current_month -le 9 ]]; then
        season="SUMMER"
    else
        season="FALL"
    fi

    echo "üìÖ Current season: $season $(date +%Y)"
    _anime_browse_and_download "" "1080p" "SubsPlease"
}

# Fansub-specific interface
_anime_fansub_interface() {
    local fansub_options="SubsPlease\nErai-raws\nDameDesuYo\nHorribleSubs\nCommie\nAniplex"
    local fansub_count=$(echo -e "$fansub_options" | wc -l)
    local fansub_height=$(_calculate_fzf_height $fansub_count)

    local fansub=$(echo -e "$fansub_options" | fzf \
        --prompt="üë• Fansub ‚Ä∫ " \
        --height="${fansub_height}" \
        --border=rounded \
        --border-label=" Select Fansub Group " \
        --border-label-pos=2 \
        --cycle)

    if [[ -n "$fansub" ]]; then
        echo "Enter anime name (or leave empty for all from $fansub):"
        read -r search_term

        local quality_options="1080p\n720p\n480p\nAny Quality"
        local quality_count=$(echo -e "$quality_options" | wc -l)
        local quality_height=$(_calculate_fzf_height $quality_count)

        local quality=$(echo -e "$quality_options" | fzf \
            --prompt="üì∫ Quality ‚Ä∫ " \
            --height="${quality_height}" \
            --border=rounded \
            --border-label=" Select Quality " \
            --border-label-pos=2 \
            --cycle)
        [[ "$quality" == "Any Quality" ]] && quality=""

        _anime_browse_and_download "$search_term" "$quality" "$fansub"
    fi
}

# RSS setup interface
_anime_rss_interface() {
    echo "Enter anime name for RSS setup:"
    read -r anime_name

    if [[ -z "$anime_name" ]]; then
        echo "No anime name provided."
        return 1
    fi

    local quality_options="1080p\n720p\n480p"
    local quality_count=$(echo -e "$quality_options" | wc -l)
    local quality_height=$(_calculate_fzf_height $quality_count)

    local quality=$(echo -e "$quality_options" | fzf \
        --prompt="üì∫ Quality ‚Ä∫ " \
        --height="${quality_height}" \
        --border=rounded \
        --border-label=" RSS Quality " \
        --border-label-pos=2 \
        --cycle)

    local fansub_options="SubsPlease\nErai-raws\nDameDesuYo"
    local fansub_count=$(echo -e "$fansub_options" | wc -l)
    local fansub_height=$(_calculate_fzf_height $fansub_count)

    local fansub=$(echo -e "$fansub_options" | fzf \
        --prompt="üë• Fansub ‚Ä∫ " \
        --height="${fansub_height}" \
        --border=rounded \
        --border-label=" RSS Fansub Group " \
        --border-label-pos=2 \
        --cycle)

    _setup_rss_feed "$anime_name" "$quality" "$fansub"
}

# Core function to fetch, display, and handle anime selection
_anime_browse_and_download() {
    local search_term="$1"
    local quality="$2"
    local fansub="$3"
    local max_results=50

    # Build RSS URL
    local rss_url="https://nyaa.si/?page=rss&c=1_2&f=0"
    [[ -n "$search_term" ]] && rss_url="https://nyaa.si/?page=rss&q=${search_term// /+}&c=1_2&f=0"

    # Try SubsPlease RSS if conditions match
    if [[ "$fansub" == "SubsPlease" && -z "$search_term" && "$quality" == "1080p" ]]; then
        local subsplease_url="https://subsplease.org/rss/?t&r=1080"
        if fetch_url "$subsplease_url" | grep -q "<item>"; then
            rss_url="$subsplease_url"
        fi
    fi

    echo "üîç Fetching anime torrents..."

    # Create temporary file for torrent data
    local temp_file=$(mktemp)
    local display_file=$(mktemp)

    # Improved RSS parsing with better ID extraction
    fetch_url "$rss_url" | awk -v fansub="$fansub" -v quality="$quality" -v max_results="$max_results" '
    BEGIN {
        RS = "<item>";
        FS = "\n";
        count = 0;
    }
    NR > 1 {
        title = ""; pubDate = ""; id = ""; link = "";
        
        for (i=1; i<=NF; i++) {
            if ($i ~ /<title>/) {
                gsub(/<title>|<\/title>/, "", $i);
                # Clean up title - remove extra whitespace and HTML entities
                gsub(/&amp;/, "\\&", $i);
                gsub(/&lt;/, "<", $i);
                gsub(/&gt;/, ">", $i);
                gsub(/&quot;/, "\"", $i);
                gsub(/^\s+|\s+$/, "", $i);
                title = $i;
            }
            else if ($i ~ /<pubDate>/) {
                gsub(/<pubDate>|<\/pubDate>/, "", $i);
                pubDate = $i;
            }
            else if ($i ~ /<link>/) {
                gsub(/<link>|<\/link>/, "", $i);
                link = $i;
                # Extract ID from different possible link formats
                if (match(link, /\/download\/([0-9]+)/, arr)) {
                    id = arr[1];
                } else if (match(link, /\/view\/([0-9]+)/, arr)) {
                    id = arr[1];
                } else if (match(link, /[^0-9]([0-9]{6,})/, arr)) {
                    id = arr[1];
                }
            }
            else if ($i ~ /<guid>/) {
                # Fallback: try to extract ID from GUID if link didnt work
                if (id == "" && match($i, /([0-9]{6,})/, arr)) {
                    id = arr[1];
                }
            }
        }

        # Validate we have all required fields
        if (title != "" && pubDate != "" && id != "" && length(id) >= 6) {
            matches = 1;

            # Apply filters
            if (fansub != "" && index(tolower(title), tolower(fansub)) == 0) {
                matches = 0;
            }
            if (quality != "" && index(tolower(title), tolower(quality)) == 0) {
                matches = 0;
            }

            if (matches) {
                count++;
                if (count <= max_results) {
                    # Format: date | title | id
                    printf("%s|%s|%s\n", pubDate, title, id);
                }
            }
        }
    }' > "$temp_file"

    # Check if we got results
    if [[ ! -s "$temp_file" ]]; then
        echo "No anime torrents found matching your criteria."
        rm -f "$temp_file" "$display_file"
        return 1
    fi

    # Count results for dynamic height
    local result_count=$(wc -l < "$temp_file")
    local display_height=$(_calculate_fzf_height $result_count)

    # Create improved display format for fzf
    awk -F'|' '{
        # Clean and truncate title
        title = $2;
        gsub(/^\s+|\s+$/, "", title);  # Remove leading/trailing whitespace
        
        # Extract and format date
        date_str = $1;
        gsub(/^[A-Za-z]+,\s*/, "", date_str);  # Remove "Mon, " etc
        split(date_str, date_parts, " ");
        
        # Format: "02 Jan" for better readability
        if (length(date_parts) >= 2) {
            day = date_parts[1];
            month = substr(date_parts[2], 1, 3);
            # Pad day with zero if needed
            if (length(day) == 1) day = "0" day;
            short_date = day " " month;
        } else {
            short_date = substr(date_str, 1, 6);
        }
        
        # Ensure ID is valid
        id = $3;
        if (length(id) < 6) {
            id = "N/A";
        }
        
        # Truncate title based on terminal width consideration
        # Format: üìÖ DD MMM üì∫ Title... üÜî ID
        date_part_length = length(short_date) + 6;  # "üìÖ " + date + " "
        id_part_length = length(id) + 6;           # " üÜî " + id
        available_for_title = 85 - date_part_length - id_part_length;
        
        if (length(title) > available_for_title) {
            title = substr(title, 1, available_for_title - 3) "...";
        }
        
        # Nice formatted output with proper spacing
        printf("üìÖ %s üì∫ %s üÜî %s\n", short_date, title, id);
    }' "$temp_file" > "$display_file"

    # FZF selection with multi-select enabled and improved preview
    local selections=$(cat "$display_file" | fzf \
        --multi \
        --prompt="üéØ Select ‚Ä∫ " \
        --height="${display_height}" \
        --border=rounded \
        --border-label=" Anime Torrents (TAB: multi-select) " \
        --border-label-pos=2 \
        --preview='echo "üìÖ Date: $(echo {} | sed "s/üìÖ \([^üì∫]*\) üì∫.*/\1/")" && echo "üÜî ID: $(echo {} | sed "s/.*üÜî \([^ ]*\)$/\1/")" && echo "üì∫ Title:" && echo {} | sed "s/üìÖ [^üì∫]* üì∫ \(.*\) üÜî [^ ]*$/\1/" | fold -w 60' \
        --preview-window=up:5:wrap \
        --bind='ctrl-a:select-all,ctrl-d:deselect-all,ctrl-t:toggle-all' \
        --cycle \
        --info=inline)

    if [[ -z "$selections" ]]; then
        echo "No selection made."
        rm -f "$temp_file" "$display_file"
        return 0
    fi

    # Process selections
    local method_options="üß≤ Magnet Links (Recommended)\nüìÅ Torrent Files"
    local method_count=$(echo -e "$method_options" | wc -l)
    local method_height=$(_calculate_fzf_height $method_count)

    local download_method=$(echo -e "$method_options" | fzf \
        --prompt="‚¨áÔ∏è  Method ‚Ä∫ " \
        --height="${method_height}" \
        --border=rounded \
        --border-label=" Download Method " \
        --border-label-pos=2 \
        --cycle)

    echo "$selections" | while IFS= read -r line; do
        # Extract torrent ID and title from the formatted line
        local torrent_id=$(echo "$line" | sed 's/.*üÜî \([^ ]*\)$/\1/')
        local title=$(echo "$line" | sed 's/üìÖ [^üì∫]* üì∫ \(.*\) üÜî [^ ]*$/\1/')

        echo "üîΩ Processing: $title"

        if [[ "$download_method" == *"Magnet"* ]]; then
            _download_magnet "$torrent_id"
        else
            _download_torrent "$torrent_id"
        fi

        echo "‚úÖ Added to qBittorrent"
        echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    done

    rm -f "$temp_file" "$display_file"

    # Ask if user wants to continue browsing
    local continue_options="‚úÖ Yes\n‚ùå No"
    local continue_count=$(echo -e "$continue_options" | wc -l)
    local continue_height=$(_calculate_fzf_height $continue_count)

    if echo -e "$continue_options" | fzf \
        --prompt="üîÑ Continue ‚Ä∫ " \
        --height="${continue_height}" \
        --border=rounded \
        --border-label=" Continue Browsing? " \
        --border-label-pos=2 \
        --cycle | grep -q "Yes"; then
        anime
    fi
}

# Download torrent file
_download_torrent() {
    local torrent_id="$1"

    if [[ -z "$torrent_id" || "$torrent_id" == "N/A" ]]; then
        echo "Error: No valid torrent ID provided."
        return 1
    fi

    # Create temporary directory
    local temp_dir="/tmp/anime_torrents"
    mkdir -p "$temp_dir"

    # Download torrent file
    local torrent_url="https://nyaa.si/download/$torrent_id.torrent"
    local torrent_file="$temp_dir/$torrent_id.torrent"

    if ! fetch_url "$torrent_url" > "$torrent_file"; then
        echo "Error: Failed to download torrent file."
        return 1
    fi

    # Add to qBittorrent
    if command -v qbittorrent &> /dev/null; then
        qbittorrent --save-path="$ANIME_DOWNLOAD_DIR" "$torrent_file" &
    elif command -v qbittorrent-nox &> /dev/null; then
        qbittorrent-nox --save-path="$ANIME_DOWNLOAD_DIR" "$torrent_file" &
    else
        echo "Error: qBittorrent not found. Torrent saved to: $torrent_file"
        return 1
    fi
}

# Download magnet link
_download_magnet() {
    local torrent_id="$1"

    if [[ -z "$torrent_id" || "$torrent_id" == "N/A" ]]; then
        echo "Error: No valid torrent ID provided."
        return 1
    fi

    # Get magnet link
    local magnet_link=$(fetch_url "https://nyaa.si/view/$torrent_id" | grep -o 'magnet:[^"]*' | head -1)

    if [[ -z "$magnet_link" ]]; then
        echo "Error: Failed to get magnet link for torrent ID $torrent_id."
        return 1
    fi

    # Add to qBittorrent
    if command -v qbittorrent &> /dev/null; then
        qbittorrent --save-path="$ANIME_DOWNLOAD_DIR" "$magnet_link" &
    elif command -v qbittorrent-nox &> /dev/null; then
        qbittorrent-nox --save-path="$ANIME_DOWNLOAD_DIR" "$magnet_link" &
    else
        echo "Error: qBittorrent not found."
        echo "Magnet link: $magnet_link"
        return 1
    fi
}

# RSS setup function
_setup_rss_feed() {
    local anime_name="$1"
    local quality="$2"
    local fansub="$3"

    echo "üîÑ RSS Setup for: $anime_name ($quality, $fansub)"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    echo "Steps to set up in qBittorrent:"
    echo "1. Open qBittorrent"
    echo "2. Go to View > RSS Reader"
    echo "3. Click 'New subscription' and add: https://nyaa.si/?page=rss&c=1_2&f=0"
    echo "4. Click 'RSS Downloader' button"
    echo "5. Create a new rule named: $anime_name"
    echo "6. In 'Must contain', add: $fansub $anime_name $quality"
    echo "7. Set download folder to: $ANIME_DOWNLOAD_DIR"
    echo ""

    if [[ "$fansub" == "SubsPlease" ]]; then
        echo "For SubsPlease, you can also use this direct RSS URL:"
        echo "https://subsplease.org/rss/?t&r=${quality/p/}"
        echo ""
    fi

    if echo -e "‚úÖ Yes\n‚ùå No" | fzf \
        --prompt="üöÄ Launch ‚Ä∫ " \
        --height="6" \
        --border=rounded \
        --border-label=" Open qBittorrent? " \
        --border-label-pos=2 \
        --cycle | grep -q "Yes"; then
        if command -v qbittorrent &> /dev/null; then
            qbittorrent &
        else
            echo "Error: qBittorrent not found in PATH."
        fi
    fi
}

# Help function
anime_help() {
    cat << 'EOF'
üéÆ FZF Anime Torrent Manager - Help
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Main Command:
  anime                         - Launch interactive FZF interface

Features:
  üîç Search Anime              - Search by title with quality/fansub filters
  üì∫ Latest Releases          - Browse newest anime releases
  üå∏ Seasonal Anime           - Current season anime from SubsPlease
  ‚öôÔ∏è  Browse by Fansub         - Browse specific fansub releases
  üîÑ Setup RSS                - Configure automatic episode downloads

Navigation:
  TAB                          - Select multiple torrents
  Ctrl+A                       - Select all torrents
  Ctrl+D                       - Deselect all torrents
  Ctrl+T                       - Toggle all selections
  Enter                        - Confirm selection
  Esc                          - Cancel/Go back

Tips:
  - Use multi-select (TAB) to download multiple episodes at once
  - Magnet links are faster than torrent files
  - All downloads go to: $ANIME_DOWNLOAD_DIR
  - RSS setup enables automatic episode downloads
  - Preview shows torrent details before selection

Requirements:
  - fzf (fuzzy finder)
  - qBittorrent or qBittorrent-nox
  - curl or wget
EOF
}

# Enhanced TorrentBD function with multiple download support - FIXED
torrentbd_news() {
  local rss_url="<INSERT YOUR TORRENTBD RSS URL HERE>"
  local temp_file=$(mktemp)
  local details_dir=$(mktemp -d)
  local download_dir="$HOME/Videos"

  # Make sure download directory exists
  mkdir -p "$download_dir"

  # Fetch RSS feed
  echo "Fetching latest torrents from TorrentBD..."
  curl -s "$rss_url" > "$temp_file"

  if [[ $? -ne 0 ]]; then
    echo "Failed to fetch RSS feed. Check your internet connection."
    rm -f "$temp_file"
    rmdir "$details_dir" 2>/dev/null
    return 1
  fi

  # Process and extract data from RSS (same as before)
  local count=1
  local display_list="${details_dir}/display.txt"
  touch "$display_list"

  grep -A20 "<item>" "$temp_file" | tr -d '\n' | sed 's/<item>/\n<item>/g' | grep "<item>" | while read -r item; do
    local title=$(echo "$item" | grep -o '<title>.*</title>' | sed 's/<title>\(.*\)<\/title>/\1/' | sed 's/&amp;/\&/g' | sed 's/&#039;/'"'"'/g')
    [[ "$title" == "TorrentBD" ]] && continue

    local link=$(echo "$item" | grep -o '<link>.*</link>' | sed 's/<link>\(.*\)<\/link>/\1/' | sed 's/&amp;/\&/g')
    local category=$(echo "$item" | grep -o '<category>.*</category>' | sed 's/<category>\(.*\)<\/category>/\1/' | sed 's/^ *//' | sed 's/ *$//')
    local description=$(echo "$item" | grep -o '<description>.*</description>' | sed 's/<description>\(.*\)<\/description>/\1/')
    local pubdate=$(echo "$item" | grep -o '<pubDate>.*</pubDate>' | sed 's/<pubDate>\(.*\)<\/pubDate>/\1/')
    local date=$(echo "$pubdate" | awk '{print $1, $2, $3, $4}' | sed 's/,//g')
    local size=$(echo "$description" | grep -o 'Size: [^ ]* [^ ]*' | sed 's/Size: //')
    [[ -z "$size" ]] && size="N/A"
    local seeders=$(echo "$description" | grep -o 'Seeders: [0-9]*' | sed 's/Seeders: //')
    [[ -z "$seeders" ]] && seeders="0"
    local leechers=$(echo "$description" | grep -o 'Leechers: [0-9]*' | sed 's/Leechers: //')
    [[ -z "$leechers" ]] && leechers="0"

    local simple_title=$(echo "$title" | sed -E 's/([0-9]{3,4}p|WEB-DL|BluRay|WEBRip|x264|x265|AAC|DD|AC3|DDP|DTS|HEVC|REMUX|HDR|SDR|REMASTERED|AV1|10bit|AMZN|DSNP|NF|HULU|IMAX|DUBBED|DUAL|PROPER|REPACK|EXTENDED|UNCUT|UNRATED|CRITERION|FLAC).*//')
    if [[ "$simple_title" == *"S0"* && "$simple_title" == *"E0"* ]]; then
      simple_title=$(echo "$simple_title" | sed -E 's/(S[0-9]+E[0-9]+).*/\1/')
    fi
    simple_title=$(echo "$simple_title" | sed 's/ *$//')

    echo "$title" > "${details_dir}/${count}.title"
    echo "$category" > "${details_dir}/${count}.category"
    echo "$size" > "${details_dir}/${count}.size"
    echo "$seeders" > "${details_dir}/${count}.seeders"
    echo "$leechers" > "${details_dir}/${count}.leechers"
    echo "$date" > "${details_dir}/${count}.date"
    echo "$link" > "${details_dir}/${count}.link"

    printf "%-3s %s\n" "${count}." "${simple_title}" >> "$display_list"
    ((count++))
  done

  if [[ ! -s "$display_list" ]]; then
    echo "No torrents found in the RSS feed."
    rm -f "$temp_file"
    rm -rf "$details_dir"
    return 0
  fi

  # Create enhanced preview script
  cat > "${details_dir}/preview.sh" << 'EOF'
#!/bin/bash
line="$1"
details_dir="$2"

idx=$(echo "$line" | awk '{print $1}' | sed 's/\.//')

if [[ -f "${details_dir}/${idx}.title" ]]; then
  title=$(cat "${details_dir}/${idx}.title")
  category=$(cat "${details_dir}/${idx}.category")
  size=$(cat "${details_dir}/${idx}.size")
  seeders=$(cat "${details_dir}/${idx}.seeders")
  leechers=$(cat "${details_dir}/${idx}.leechers")
  date=$(cat "${details_dir}/${idx}.date")

  echo -e "\033[1;36m=== TORRENT DETAILS ===\033[0m"
  echo -e "\033[1;33mTitle:\033[0m $title"
  echo -e "\033[1;33mCategory:\033[0m $category"
  echo -e "\033[1;33mSize:\033[0m $size"
  echo -e "\033[1;33mSeeders:\033[0m $seeders"
  echo -e "\033[1;33mLeechers:\033[0m $leechers"
  echo -e "\033[1;33mDate:\033[0m $date"
  echo ""
  echo -e "\033[1;32m‚ñ∂ Press Enter to download\033[0m"
  echo -e "\033[1;34m‚ñ∂ Press Ctrl+C to go back\033[0m"
else
  echo -e "\033[1;31mDetails not found for item $idx\033[0m"
fi
EOF
  chmod +x "${details_dir}/preview.sh"

  # Main download loop
  while true; do
    local fzf_header="TorrentBD - Enter: Download | Tab: Multi-select | Esc: Quit | Ctrl+R: Refresh"
    local selected_lines=$(cat "$display_list" | \
      fzf --height=80% \
          --layout=reverse \
          --border=rounded \
          --header="$fzf_header" \
          --preview="${details_dir}/preview.sh {} ${details_dir}" \
          --preview-window=right:50%:wrap \
          --prompt="Select torrent(s) > " \
          --pointer="‚ñ∂" \
          --marker="‚úì" \
          --multi \
          --bind='ctrl-r:reload(cat '"$display_list"')')

    # If user cancelled selection
    if [[ -z "$selected_lines" ]]; then
      echo "Exiting TorrentBD..."
      break
    fi

    # Process each selected torrent
    local download_count=0
    while IFS= read -r selected_line; do
      [[ -z "$selected_line" ]] && continue

      local choice=$(echo "$selected_line" | awk '{print $1}' | sed 's/\.//')

      if [[ -f "${details_dir}/${choice}.title" && -f "${details_dir}/${choice}.link" ]]; then
        local title=$(cat "${details_dir}/${choice}.title")
        local link=$(cat "${details_dir}/${choice}.link")
        local safe_title=$(echo "$title" | sed 's/[<>:"|?*]/_/g')
        local torrent_filename="${download_dir}/${safe_title// /_}.torrent"

        echo "[$((download_count + 1))] Downloading: $title"
        curl -s -L "$link" -o "$torrent_filename"

        if [[ $? -eq 0 ]]; then
          echo "‚úì Saved: $(basename "$torrent_filename")"
          ((download_count++))
        else
          echo "‚úó Failed to download: $title"
        fi
      fi
    done <<< "$selected_lines"

    if [[ $download_count -gt 0 ]]; then
      echo ""
      echo "Downloaded $download_count torrent file(s) to: $download_dir"

      # Ask if user wants to open qBittorrent - FIXED VERSION
      echo ""
      printf "Open qBittorrent now? (y/N): "
      read -r qbt_reply < /dev/tty
      if [[ "$qbt_reply" =~ ^[Yy]$ ]]; then
        if command -v qbittorrent >/dev/null 2>&1; then
          echo "Opening qBittorrent..."
          qbittorrent >/dev/null 2>&1 &
          disown
        else
          echo "qBittorrent not found. Please install it or manually open the torrent files."
        fi
      fi
    fi

    # Ask if user wants to continue - FIXED VERSION
    echo ""
    printf "Download more torrents? (Y/n): "
    read -r continue_reply < /dev/tty
    if [[ "$continue_reply" =~ ^[Nn]$ ]]; then
      break
    fi
  done

  # Clean up
  rm -f "$temp_file"
  rm -rf "$details_dir"
  echo "Session ended. Happy downloading! üè¥‚Äç‚ò†Ô∏è"
}

alias tbd="torrentbd_news"


#export PATH="$PATH:$HOME/Github/metasploit-framework"
export PATH=$HOME/.local/bin:$PATH
export PATH=$HOME/.cargo/bin:$PATH
export GOBIN=`go env GOPATH`/bin
export PATH=$PATH:$GOBIN
#alias msfconsole="pushd $HOME/Github/metasploit-framework && ./msfconsole && popd"
export VISUAL=nano
export EDITOR=nano
if [ -f /usr/bin/fastfetch ]; then
    fastfetch
fi
eval "$(oh-my-posh init zsh --config $HOME/Github/fun007/configs/illusi0n_mod.omp.json)"
