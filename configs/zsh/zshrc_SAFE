# Set the directory we want to store zinit and plugins
ZINIT_HOME="${XDG_DATA_HOME:-${HOME}/.local/share}/zinit/zinit.git"

# Download Zinit, if it's not there yet
if [ ! -d "$ZINIT_HOME" ]; then
   mkdir -p "$(dirname $ZINIT_HOME)"
   git clone https://github.com/zdharma-continuum/zinit.git "$ZINIT_HOME"
fi

# Source/Load zinit
source "${ZINIT_HOME}/zinit.zsh"

#Add in Oh-my-posh
zinit ice depth=1; zinit light jandedobbeleer/oh-my-posh 

# Add in zsh plugins
zinit light zsh-users/zsh-syntax-highlighting
zinit light zsh-users/zsh-completions
zinit light zsh-users/zsh-autosuggestions
zinit light Aloxaf/fzf-tab

# Add in snippets
zinit snippet OMZP::git
zinit snippet OMZP::sudo
zinit snippet OMZP::archlinux
zinit snippet OMZP::aws
zinit snippet OMZP::kubectl
zinit snippet OMZP::kubectx
zinit snippet OMZP::command-not-found
zinit snippet OMZP::dotenv
zinit snippet OMZP::rake
zinit snippet OMZP::rbenv
zinit snippet OMZP::ruby
#zinit snippet OMZP::adb
zinit snippet OMZP::python
zinit snippet OMZP::rust
zinit snippet OMZP::rvm
zinit snippet OMZP::ssh
zinit snippet OMZP::svn
zinit snippet OMZP::thefuck
zinit snippet OMZP::tmux
zinit snippet OMZP::tldr
zinit snippet OMZP::sdk
zinit snippet OMZP::zoxide
#zinit snippet OMZP::zsh-navigation-tools
#zinit snippet OMZP::ufw

# Load completions
autoload -Uz compinit && compinit

zinit cdreplay -q

# History
HISTSIZE=5000
HISTFILE=$HOME/.zsh_history
SAVEHIST=$HISTSIZE
HISTDUP=erase
setopt appendhistory
setopt sharehistory
setopt hist_ignore_space
setopt hist_ignore_all_dups
setopt hist_save_no_dups
setopt hist_ignore_dups
setopt hist_find_no_dups

# Completion styling
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Za-z}'
zstyle ':completion:*' list-colors "${(s.:.)LS_COLORS}"
zstyle ':completion:*' menu no
zstyle ':fzf-tab:complete:cd:*' fzf-preview 'ls --color $realpath'
zstyle ':fzf-tab:complete:__zoxide_z:*' fzf-preview 'ls --color $realpath'

# Shell integrations
eval "$(fzf --zsh)"
eval "$(zoxide init --cmd cd zsh)"

# Keybindings
bindkey -e
bindkey '^p' history-search-backward
bindkey '^n' history-search-forward
bindkey '^[w' kill-region

# Common Keybindings
bindkey "^[[H" beginning-of-line # Home key
bindkey "^[[F" end-of-line # End key
bindkey "^[[P" delete-char # Del key
bindkey "^[[A" history-beginning-search-backward # Up Arrow
bindkey "^[[B" history-beginning-search-forward # Down Arrow
bindkey "^[[1;5C" forward-word # Control + Right Arrow
bindkey "^[[1;5D" backward-word # Control + Left Arrow
bindkey "^H" backward-kill-word # Control + Backspace
bindkey "^[[M" kill-word # Control + Delete
bindkey "^[[7~" beginning-of-line # Home key
bindkey "^[[8~" end-of-line # End key
bindkey "^[[3~" delete-char # Del key
bindkey "^[Oc" forward-word # Control + Right Arrow
bindkey "^[Od" backward-word # Control + Left Arrow
bindkey "^[[3^" kill-word # Control + Delete

# Additional Keybindings
bindkey "^R" history-incremental-pattern-search-backward
bindkey "^S" history-incremental-pattern-search-forward

# Aliases
alias reboot='sudo reboot +0'
alias shutdown='sudo shutdown +0'
alias h="cat $HOME/.zsh_history | grep "
alias ezrc='nano $HOME/.zshrc'
alias hlp='cat $HOME/zshrc_aliases.md'
alias vi='nvim'
alias svi='sudo vi'
alias vis='nvim "+set si"'
alias vim='nvim'
alias c='clear'
alias cp='cp -iv --reflink=auto'
alias rcp='rsync -v --progress'
alias rmv='rsync -v --progress --remove-source-files'
alias mv='mv -iv'
alias less='less -R'
alias ln='ln -v'
alias chmod='chmod -c'
alias chown='chown -c'
alias mkdir='mkdir -v'
alias grep='grep --colour=auto'
#alias egrep='grep -E --colour=auto'
alias pbcopy='xclip -selection clipboard'
alias pbpaste='xclip -selection clipboard -o'
alias ls='eza'
alias ll='eza -alh'
alias tree='eza --tree'
alias clear-pacman-cache='sudo pacman -Sc'
alias clear-cache='yay -Sc'
alias passwdGEN='python3 $HOME/Github/fun007/Passwd_Generator/passwd_gen.py -c -n -s 19 | grep "Generated Password:" | awk "{print \$3}" | tee >(pbcopy)'
alias rm='rm -f'
alias rmd='rm -rf'
alias ping='ping -c 10'
alias x='exit'
alias multitail='multitail --no-repeat -c'
alias freshclam='sudo freshclam'
alias alert='notify-send --urgency=low -i "$([ $? = 0 ] && printf terminal || printf error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'
alias da='date "+%Y-%m-%d %A %T %Z"'
alias genSRCINFO='makepkg --printsrcinfo > .SRCINFO'
alias kc='khal calendar'
alias yayf="yay -Slq | fzf --multi --preview 'yay -Sii {1}' --preview-window=down:75% | xargs -ro yay -S"

# fastfetch utils
alias ff='fastfetch'

ff-upd() {
    cd $HOME/fastfetch || return
    
    output=$(git pull)

    # Check if the output indicates "Already up to date."
    if [[ $output == *"Already up to date."* ]]; then
        printf "Fastfetch is already up to date. No need to rebuild.\n"
        cd
    else
        cd $HOME/fastfetch/build || return
        
        # Remove all contents in the build directory
        rm -rf *
        
        # Rebuild and install Fastfetch
        cmake .. && cmake --build . --target package && sudo cmake --install . --prefix /usr/
        
        cd
    fi
}


# egrep error escape logic
egrep() {
  grep -E --colour=auto "$@" 2>/dev/null
}

# Change directory aliases
alias home='cd $HOME'
alias cd..='cd ..'
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'

# alias chmod commands
alias mx='chmod a+x'
alias 000='chmod -R 000'
alias 644='chmod -R 644'
alias 666='chmod -R 666'
alias 755='chmod -R 755'
alias 777='chmod -R 777'



if command -v bat > /dev/null; then
     alias cat="bat"
elif command -v batcat > /dev/null; then
     alias cat="batcat"
fi

if command -v colordiff > /dev/null 2>&1; then
    alias diff="colordiff -Nuar"
else
    alias diff="diff -Nuar"
fi

# Alias's for archives
alias mktar='tar -cvf'
alias mkbz2='tar -cvjf'
alias mkgz='tar -cvzf'
alias untar='tar -xvf'
alias unbz2='tar -xvjf'
alias ungz='tar -xvzf'

# Extracts any archive(s) (if unp isn't installed)
extract() {
    for archive in "$@"; do
        if [ -f "$archive" ]; then
            case $archive in
            *.tar.bz2) tar xvjf $archive ;;
            *.tar.gz) tar xvzf $archive ;;
            *.tar.xz) tar xvJf $archive ;;
            *.bz2) bunzip2 $archive ;;
            *.rar) unrar x $archive ;;
            *.gz) gunzip $archive ;;
            *.tar) tar xvf $archive ;;
            *.tbz2) tar xvjf $archive ;;
            *.tgz) tar xvzf $archive ;;
            *.zip) unzip $archive ;;
            *.Z) uncompress $archive ;;
            *.7z) 7z x $archive ;;
            *.xz) unxz $archive ;;
            *) printf "don't know how to extract '%s'...\n" "$archive" ;;
            esac
        else
            printf "'%s' is not a valid file!\n" "$archive"
        fi
    done
}

# Automated encryption and decryption on file/folders
mkcryptgz() {
    if [[ -d "$1" ]]; then
        tarball="${1}.tar.gz"
        tar -czf "$tarball" "$1" && gpg --output "${tarball}.gpg" --symmetric "$tarball" && rm "$tarball"
        if [[ $? -eq 0 ]]; then
            printf "Directory '%s' compressed, encrypted, and original archive removed.\n" "$1"
        else
            printf "Error during compression or encryption.\n"
        fi
    else
        printf "'%s' is not a valid directory!\n" "$1"
    fi
}

ungpgextract() {
    if [[ -f "$1" ]]; then
        output_file="${1%.gpg}"
        gpg --output "$output_file" --decrypt "$1"
        
        if [[ $? -eq 0 ]]; then
            extract "$output_file"
            if [[ $? -eq 0 ]]; then
                rm "$output_file"
                printf "Decrypted, extracted, and removed: %s\n" "$output_file"
            else
                printf "Extraction failed.\n"
            fi
        else
            printf "Decryption failed.\n"
        fi
    else
        printf "'%s' is not a valid file!\n" "$1"
    fi
}


# Searches for text in all files in the current folder
ftext() {
    # -i case-insensitive
    # -I ignore binary files
    # -H causes filename to be printed
    # -r recursive search
    # -n causes line number to be printed
    # optional: -F treat search term as a literal, not a regular expression
    # optional: -l only print filenames and not the matching lines ex. grep -irl "$1" *
    grep -iIHrn --color=always "$1" . | less -r
}

# Alias to show football fixtures
#alias ffix='$HOME/DWM/scripts/footballfix'

# Finds and adds fastest mirror lists for pacman
httpsmirrors() {
    temp_mirrorlist=$(mktemp)  # Correctly create a temporary file

    # Generate the new mirrorlist
    rate-mirrors --allow-root --protocol https arch | awk "/^# FINISHED AT:/ {p=1} p" > "$temp_mirrorlist"

    # Check if the output is non-empty
    if [ -s "$temp_mirrorlist" ]; then
        # Attempt to update the mirrorlist with sudo
        if sudo tee /etc/pacman.d/mirrorlist < "$temp_mirrorlist" > /dev/null; then
            printf "Mirrorlist updated successfully.\n"
        else
            printf "Failed to update mirrorlist due to sudo error.\n"
        fi
    else
        printf "Failed to generate new mirrorlist. Retaining the previous list.\n"
    fi

    rm -f "$temp_mirrorlist"  # Always remove the temporary file
}

# Alias to show all established connections and their resolved names
alias show_connections='sudo netstat -tupn | grep "ESTABLISHED" | awk '\''{print $5}'\'' | cut -d: -f1 | sort | uniq | xargs -I {} sh -c '\''printf "%s: " "{}"; nslookup {}'\'' | grep "name ="'

# Alias to show the external NAT'ed IP
alias external_ip='IP=$(curl -s https://api.ipify.org) && printf "This is your External IP address %s.\n" "$IP"'

# Alias to show the installation date of the system
install_date() {
  install_date=$(sudo btrfs subvolume show / | grep "Creation time" | awk -F": " '{print $2}' | xargs)
  printf "Your Arch Linux OS was installed on %s.\n" "$install_date"
}

# Alias to show the last reboot time of the system
alias last_reboot='FQDN=$(uname -n); hostname=$(printf "%s" "$FQDN" | cut -d. -f1); last_reboot=$(date -d @$(( $(date +%s) - $(awk '\''{print int($1)}'\'' /proc/uptime) ))); printf "The %s system was last rebooted on %s.\n" "$hostname" "$last_reboot"'

# Alias to try out your new theme using color scripts from the Color-Scripts repository
alias random_color_script='COLOR_SCRIPT_REPO=https://api.github.com/repos/stark/Color-Scripts/contents/color-scripts; wget -q -O - $(curl -s $COLOR_SCRIPT_REPO | jq ".[] | \"\(.path) \(.download_url)\"" -r | shuf -n1 | cut -d " " -f2) | bash'

# Alias for quick access to weather
alias opwttr='$HOME/DWM/scripts/OpWeatherinfo'

# IP address lookup
alias whatismyip="whatsmyip"
function whatsmyip ()
{
    # Internal IP Lookup.
    if [ -e /usr/bin/ip ]; then
        printf "Internal IP: "
        /usr/bin/ip addr show wlp0s20f3 | grep "inet " | awk -F: '{print $1}' | awk '{print $2}'
    else
        printf "Internal IP: "
        /usr/bin/ifconfig wlp0s20f3 | grep "inet " | awk -F: '{print $1} |' | awk '{print $2}'
    fi

    # External IP Lookup
    printf "External IP: "
    printf "%s\n" "$(curl -s ifconfig.me)"
}

# Search running processes
alias p="ps aux | grep "
alias topcpu="/bin/ps -eo pcpu,pid,user,args | sort -k 1 -r | head -10"

# Search files in the current folder
alias f="find . | grep "

# Count all files (recursively) in the current folder
alias countfiles="for t in files links directories; do printf \"%s %s\n\" \"\$(find . -type \${t:0:1} | wc -l)\" \"\$t\"; done 2> /dev/null"

# To see if a command is aliased, a file, or a built-in command
alias checkcommand="type -t"

# Show open ports
alias openports='netstat -nape --inet'

# Alias's to show disk space and space used in a folder
alias diskspace="du -S | sort -n -r |more"
alias folders='du -h --max-depth=1'
alias folderssort='find . -maxdepth 1 -type d -print0 | xargs -0 du -sk | sort -rn'
alias treed='tree -CAFd'
alias mountedinfo='df -hT'

# Show all logs in /var/log
alias logs="sudo find /var/log -type f -exec file {} \; | grep 'text' | cut -d' ' -f1 | sed -e's/:$//g' | grep -v '[0-9]$' | xargs sudo tail -f"

# SHA1
alias sha1='openssl sha1'

alias clickpaste='sleep 3; xdotool type "$(xclip -o -selection clipboard)"'

# KITTY - alias to be able to use kitty features when connecting to remote servers(e.g use tmux on remote server)
alias kssh="kitty +kitten ssh"

# QP var chooser
filter_papers() {
  local file=$1
  local keep_qp=$2
  
  awk '!/"$keep_qp"'[1-9]/ "$file" > filtered_results.dat
}

# Copy file with a progress bar
cpp() {
    set -e
    strace -q -ewrite cp -- "${1}" "${2}" 2>&1 |
        awk '{
    count += $NF
    if (count % 10 == 0) {
        percent = count / total_size * 100
        printf "%3d%% [", percent
        for (i=0;i<=percent;i++)
            printf "="
            printf ">"
            for (i=percent;i<100;i++)
                printf " "
                printf "]\r"
            }
        }
    END { printf "\n" }' total_size="$(stat -c '%s' "${1}")" count=0
}

# Copy and go to the directory
cpg() {
    if [ -d "$2" ]; then
        cp "$1" "$2" && cd "$2"
    else
        cp "$1" "$2"
    fi
}

# Move and go to the directory
mvg() {
    if [ -d "$2" ]; then
        mv "$1" "$2" && cd "$2"
    else
        mv "$1" "$2"
    fi
}

# Create and go to the directory
mkdirg() {
    mkdir -p "$1"
    cd "$1"
}

# Goes up a specified number of directories  (i.e. up 4)
up() {
    local d=""
    limit=$1
    for ((i = 1; i <= limit; i++)); do
        d=$d/..
    done
    d=$(printf "%s" "$d" | sed 's/^\///')
    if [ -z "$d" ]; then
        d=..
    fi
    cd $d
}

# Returns the last 2 fields of the working directory
pwdtail() {
    pwd | awk -F/ '{nlast = NF -1;print $nlast"/"$NF}'
}

# Show the current distribution
distribution ()
{
    local dtype="unknown"  # Default to unknown

    # Use /etc/os-release for modern distro identification
    if [ -r /etc/os-release ]; then
        source /etc/os-release
        case $ID in
            fedora|rhel|centos)
                dtype="redhat"
                ;;
            sles|opensuse*)
                dtype="suse"
                ;;
            ubuntu|debian)
                dtype="debian"
                ;;
            gentoo)
                dtype="gentoo"
                ;;
            arch)
                dtype="arch"
                ;;
            slackware)
                dtype="slackware"
                ;;
            *)
                # If ID is not recognized, keep dtype as unknown
                ;;
        esac
    fi

    printf "%s\n" "$dtype"
}

# Show the current version of the operating system
ver() {
    local dtype
    dtype=$(distribution)

    case $dtype in
        "redhat")
            if [ -s /etc/redhat-release ]; then
                cat /etc/redhat-release
            else
                cat /etc/issue
            fi
            uname -a
            ;;
        "suse")
            cat /etc/SuSE-release
            ;;
        "debian")
            lsb_release -a
            ;;
        "gentoo")
            cat /etc/gentoo-release
            ;;
        "arch")
            cat /etc/os-release
            ;;
        "slackware")
            cat /etc/slackware-version
            ;;
        *)
            if [ -s /etc/issue ]; then
                cat /etc/issue
            else
                printf "Error: Unknown distribution\n"
                exit 1
            fi
            ;;
    esac
}

# View Apache logs
apachelog() {
    if [ -f /etc/httpd/conf/httpd.conf ]; then
        cd /var/log/httpd && ls -xAh && multitail --no-repeat -c -s 2 /var/log/httpd/*_log
    else
        cd /var/log/apache2 && ls -xAh && multitail --no-repeat -c -s 2 /var/log/apache2/*.log
    fi
}

# Edit the Apache configuration
apacheconfig() {
    if [ -f /etc/httpd/conf/httpd.conf ]; then
        nano /etc/httpd/conf/httpd.conf
    elif [ -f /etc/apache2/apache2.conf ]; then
        nano /etc/apache2/apache2.conf
    else
        printf "Error: Apache config file could not be found.\n"
        printf "Searching for possible locations:\n"
        sudo updatedb && locate httpd.conf && locate apache2.conf
    fi
}

# Edit the PHP configuration file
phpconfig() {
    if [ -f /etc/php.ini ]; then
        nano /etc/php.ini
    elif [ -f /etc/php/php.ini ]; then
        nano /etc/php/php.ini
    elif [ -f /etc/php5/php.ini ]; then
        nano /etc/php5/php.ini
    elif [ -f /usr/bin/php5/bin/php.ini ]; then
        nano /usr/bin/php5/bin/php.ini
    elif [ -f /etc/php5/apache2/php.ini ]; then
        nano /etc/php5/apache2/php.ini
    else
        printf "Error: php.ini file could not be found.\n"
        printf "Searching for possible locations:\n"
        sudo updatedb && locate php.ini
    fi
}

# Edit the MySQL configuration file
mysqlconfig() {
    if [ -f /etc/my.cnf ]; then
        nano /etc/my.cnf
    elif [ -f /etc/mysql/my.cnf ]; then
        nano /etc/mysql/my.cnf
    elif [ -f /usr/local/etc/my.cnf ]; then
        nano /usr/local/etc/my.cnf
    elif [ -f /usr/bin/mysql/my.cnf ]; then
        nano /usr/bin/mysql/my.cnf
    elif [ -f $HOME/my.cnf ]; then
        nano $HOME/my.cnf
    elif [ -f $HOME/.my.cnf ]; then
        nano $HOME/.my.cnf
    else
        printf "Error: my.cnf file could not be found.\n"
        printf "Searching for possible locations:\n"
        sudo updatedb && locate my.cnf
    fi
}


# Trim leading and trailing spaces (for scripts)
trim() {
    local var=$*
    var="${var#"${var%%[![:space:]]*}"}" # remove leading whitespace characters
    var="${var%"${var##*[![:space:]]}"}" # remove trailing whitespace characters
    printf "%s" "$var"
}

# GitHub Additions

gcom() {
    git add .
    git commit -m "$1"
}

lazyg() {
    git pull --rebase
    git add .
    git commit -m "$1"
    git push
}

# Function to switch to Cloudflare DNS
cloudflare_dns() {
    printf "nameserver 1.1.1.2\nnameserver 1.0.0.2\n" | sudo tee /etc/resolv.conf > /dev/null
    printf "Switched to Cloudflare DNS\n"
}

# Function to switch to Quad9 DNS
quad9_dns() {
    printf "nameserver 9.9.9.11\nnameserver 149.112.112.11\n" | sudo tee /etc/resolv.conf > /dev/null
    printf "Switched to Quad9 DNS\n"
}

dwn_iso() {
    local iso_dir="$HOME/Downloads/ISO"
    mkdir -p "$iso_dir"
    
    # Arch Linux URLs (primary and fallback)
    local arch_url_base1="https://mirror.rackspace.com/archlinux/iso/latest/"
    local arch_url_base2="https://geo.mirror.pkgbuild.com/iso/latest/"

    # Tails base URL
    local tails_url_base="https://mirrors.edge.kernel.org/tails/stable/"

    # Function to download Arch Linux ISO
    download_arch_iso() {
        local arch_latest_ver=$(curl -sL "${arch_url_base1}" | grep -oP 'archlinux-\K[0-9]{4}\.[0-9]{2}\.[0-9]{2}' | head -n 1)
        local iso_filename="archlinux-${arch_latest_ver}-x86_64.iso"
    
        # Check if the ISO already exists
        if [ -f "$iso_dir/$iso_filename" ]; then
            echo "Arch ISO is already the latest version: $iso_filename"
        else
            # Download from primary and fallback if necessary
            if ! curl -o "$iso_dir/$iso_filename" "${arch_url_base1}${iso_filename}"; then
                echo "Primary Arch URL failed, attempting fallback..."
                curl -o "$iso_dir/$iso_filename" "${arch_url_base2}${iso_filename}"
            fi
    
            # Download the verification files
            curl -o "$iso_dir/sha256sums.txt" "${arch_url_base1}sha256sums.txt" || curl -o "$iso_dir/sha256sums.txt" "${arch_url_base2}sha256sums.txt"
            curl -o "$iso_dir/b2sums.txt" "${arch_url_base1}b2sums.txt" || curl -o "$iso_dir/b2sums.txt" "${arch_url_base2}b2sums.txt"
            curl -o "$iso_dir/${iso_filename}.sig" "${arch_url_base1}${iso_filename}.sig" || curl -o "$iso_dir/${iso_filename}.sig" "${arch_url_base2}${iso_filename}.sig"
    
            # Download and import Arch Linux signing keys if needed
            if ! gpg --list-keys 76A5EF9054449A5C &>/dev/null; then
                echo "Downloading Arch Linux signing key..."
                gpg --auto-key-locate clear,wkd -v --locate-external-key pierre@archlinux.org
            fi
    
            # Run ISO verification script
            sh "$iso_dir/iso_verifier.sh" "$iso_dir/$iso_filename"
        fi
    }

    # Function to download Tails ISO
    download_tails_iso() {
        local tails_latest_ver=$(curl -sL "${tails_url_base}" | grep -oP 'tails-amd64-\K[0-9]+\.[0-9]+(?=/)' | sort -V | tail -n 1)
        local iso_filename="tails-amd64-${tails_latest_ver}.iso"

        # Check if the ISO already exists
        if [ -f "$iso_dir/$iso_filename" ]; then
            echo "Tails ISO is already the latest version: $iso_filename"
        else
            # Download the ISO and .sig file
            curl -o "$iso_dir/$iso_filename" "${tails_url_base}tails-amd64-${tails_latest_ver}/$iso_filename"
            curl -o "$iso_dir/$iso_filename.sig" "${tails_url_base}tails-amd64-${tails_latest_ver}/$iso_filename.sig"

            # Run ISO verification script (only GPG signature)
            sh "$iso_dir/iso_verifier.sh" "$iso_dir/$iso_filename"
        fi
    }

    # Main logic
    echo "Checking for new Arch and Tails ISO versions..."

    download_arch_iso
    download_tails_iso
}

# Anime utility functions for .zshrc
# Download directory path - centralized for easy updating
ANIME_DOWNLOAD_DIR="$HOME/Videos"

# HTTP request helper function to reduce code duplication
fetch_url() {
    local url="$1"
    if command -v curl &> /dev/null; then
        curl -s "$url"
    elif command -v wget &> /dev/null; then
        wget -q -O - "$url"
    else
        echo "Error: curl or wget is required but not installed."
        return 1
    fi
}

# Function to check anime torrents from Nyaa RSS feed
anime_torrents() {
    local search_term="$1"
    local quality="${2:-1080p}"
    local fansub="${3:-}"  # Changed default to empty for true "show all" behavior
    local max_results="${4:-10}"
    local rss_url="https://nyaa.si/?page=rss&c=1_2&f=0"  # Anime - English translated
    
    # If search term provided, use specific URL
    [[ -n "$search_term" ]] && rss_url="https://nyaa.si/?page=rss&q=${search_term// /+}&c=1_2&f=0"
    
    # Try SubsPlease RSS if conditions match and it has content
    if [[ "$fansub" == "SubsPlease" && -z "$search_term" && "$quality" == "1080p" ]]; then
        local subsplease_url="https://subsplease.org/rss/?t&r=1080"
        if fetch_url "$subsplease_url" | grep -q "<item>"; then
            rss_url="$subsplease_url"
        else
            echo "Note: SubsPlease RSS feed appears empty, using Nyaa.si instead"
        fi
    fi
    
    echo "ğŸ” Fetching anime torrents from Nyaa.si..."
    echo "ğŸ“¡ RSS Feed: $rss_url"
    
    # Only show filter information if filters are actually being applied
    if [[ -n "$fansub" || -n "$quality" ]]; then
        local filter_text=""
        [[ -n "$fansub" ]] && filter_text+="$fansub"
        [[ -n "$fansub" && -n "$quality" ]] && filter_text+=", "
        [[ -n "$quality" ]] && filter_text+="$quality"
        echo "âš™ï¸  Filters: $filter_text"
    else
        echo "âš™ï¸  Filters: None (showing all releases)"
    fi
    
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    
    # Parse RSS feed with AWK (improved implementation)
    local awk_script='
    BEGIN { 
        RS = "<item>"; 
        FS = "\n"; 
        count = 0; 
        show_all = (fansub == ""); 
    }
    NR > 1 { 
        title = ""; pubDate = ""; link = ""; id = "";
        for (i=1; i<=NF; i++) {
            if ($i ~ /<title>/) {
                gsub(/<title>|<\/title>/, "", $i);
                title = $i;
            }
            else if ($i ~ /<pubDate>/) {
                gsub(/<pubDate>|<\/pubDate>/, "", $i);
                pubDate = $i;
            }
            else if ($i ~ /<link>https:\/\/nyaa.si\/download\//) {
                gsub(/<link>https:\/\/nyaa.si\/download\/|\.torrent<\/link>/, "", $i);
                id = $i;
            }
        }
        
        if (title != "" && pubDate != "" && id != "") {
            # Fix: Logic to properly handle empty filters
            matches = 1;
            
            # If fansub filter is specified, check if title contains it
            if (fansub != "" && index(tolower(title), tolower(fansub)) == 0) {
                matches = 0;
            }
            
            # If quality filter is specified, check if title contains it
            if (quality != "" && index(tolower(title), tolower(quality)) == 0) {
                matches = 0;
            }
            
            if (matches) {
                count++;
                if (count <= max_results) {
                    printf("\033[1;36m%s\033[0m\n\033[1;33m%s\033[0m\nID: \033[1;32m%s\033[0m\n\n", 
                        pubDate, title, id);
                }
            }
        }
    }'
    
    # Execute the AWK script and capture its output
    local output=$(fetch_url "$rss_url" | awk -v fansub="$fansub" -v quality="$quality" -v max_results="$max_results" "$awk_script")
    
    # Display output
    echo "$output"
    
    # Check if we got any results
    local results_found=0
    [[ -n "$output" ]] && results_found=1
    
    # If no results found, try without filters if they were applied
    if [[ $results_found -eq 0 && ("$fansub" != "" || "$quality" != "") ]]; then
        echo "No results found with current filters. Would you like to search without filters? (y/n)"
        read -r -k 1 no_filter_choice
        echo ""
        
        if [[ "$no_filter_choice" =~ [yY] ]]; then
            echo "Searching without filters..."
            echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
            anime_torrents "$search_term" "" "" "$max_results"
            return $?
        fi
    fi
    
    # Only prompt for download if we found results
    if [[ $results_found -eq 1 ]]; then
        prompt_download
        return 0
    else
        echo "No matching anime torrents found. Try different search terms or filters."
        return 1
    fi
}

# Helper function to prompt user for download choice
prompt_download() {
    echo "Do you want to download a torrent? (y/n)"
    read -r -k 1 download_choice
    echo ""
    
    if [[ "$download_choice" =~ [yY] ]]; then
        echo "Enter the torrent ID to download:"
        read -r torrent_id
        
        echo "Download method:"
        echo "1) Torrent file"
        echo "2) Magnet link (recommended)"
        read -r -k 1 method_choice
        echo ""
        
        case $method_choice in
            1) download_torrent "$torrent_id" ;;
            2) download_magnet "$torrent_id" ;;
            *) download_magnet "$torrent_id" ;;
        esac
    fi
}

# Function to download a torrent by ID directly to qBittorrent
download_torrent() {
    local torrent_id="$1"
    
    if [[ -z "$torrent_id" ]]; then
        echo "Error: No torrent ID provided."
        echo "Usage: download_torrent [torrent_id]"
        return 1
    fi
    
    echo "ğŸ”½ Downloading torrent with ID: $torrent_id"
    echo "ğŸ“ Download directory: $ANIME_DOWNLOAD_DIR"
    
    # Create temporary directory for the torrent file
    local temp_dir="/tmp/anime_torrents"
    mkdir -p "$temp_dir"
    
    # Download the torrent file
    local torrent_url="https://nyaa.si/download/$torrent_id.torrent"
    local torrent_file="$temp_dir/$torrent_id.torrent"
    
    if ! fetch_url "$torrent_url" > "$torrent_file"; then
        echo "Error: Failed to download torrent file."
        return 1
    fi
    
    # Check if the torrent file was downloaded successfully
    if [[ ! -f "$torrent_file" ]]; then
        echo "Error: Failed to download torrent file."
        return 1
    fi
    
    # Open the torrent in qBittorrent with the specified download directory
    if command -v qbittorrent &> /dev/null; then
        echo "ğŸ‘‰ Opening torrent in qBittorrent..."
        qbittorrent --save-path="$ANIME_DOWNLOAD_DIR" "$torrent_file"
        echo "âœ… Torrent added to qBittorrent with download path: $ANIME_DOWNLOAD_DIR"
    elif command -v qbittorrent-nox &> /dev/null; then
        echo "ğŸ‘‰ Adding torrent to qBittorrent (headless)..."
        qbittorrent-nox --save-path="$ANIME_DOWNLOAD_DIR" "$torrent_file"
        echo "âœ… Torrent added to qBittorrent with download path: $ANIME_DOWNLOAD_DIR"
    else
        echo "Error: qBittorrent is not installed or not in your PATH."
        echo "The torrent file has been saved to: $torrent_file"
        return 1
    fi
}

# Function to directly add a magnet link to qBittorrent
download_magnet() {
    local torrent_id="$1"
    
    if [[ -z "$torrent_id" ]]; then
        echo "Error: No torrent ID provided."
        echo "Usage: download_magnet [torrent_id]"
        return 1
    fi
    
    echo "ğŸ§² Getting magnet link for torrent ID: $torrent_id"
    echo "ğŸ“ Download directory: $ANIME_DOWNLOAD_DIR"
    
    # Get the magnet link from the Nyaa page
    local magnet_link=$(fetch_url "https://nyaa.si/view/$torrent_id" | grep -o 'magnet:[^"]*' | head -1)
    
    if [[ -z "$magnet_link" ]]; then
        echo "Error: Failed to get magnet link for torrent ID $torrent_id."
        return 1
    fi
    
    # Add the magnet link to qBittorrent
    if command -v qbittorrent &> /dev/null; then
        echo "ğŸ‘‰ Adding magnet link to qBittorrent..."
        qbittorrent --save-path="$ANIME_DOWNLOAD_DIR" "$magnet_link"
        echo "âœ… Magnet link added to qBittorrent with download path: $ANIME_DOWNLOAD_DIR"
    elif command -v qbittorrent-nox &> /dev/null; then
        echo "ğŸ‘‰ Adding magnet link to qBittorrent (headless)..."
        qbittorrent-nox --save-path="$ANIME_DOWNLOAD_DIR" "$magnet_link"
        echo "âœ… Magnet link added to qBittorrent with download path: $ANIME_DOWNLOAD_DIR"
    else
        echo "Error: qBittorrent is not installed or not in your PATH."
        echo "Magnet link: $magnet_link"
        return 1
    fi
}

# Function to show latest releases with improved sorting
latest_anime() {
    echo "ğŸ“º Latest Anime Releases"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    
    # Go directly to Nyaa.si
    local rss_url="https://nyaa.si/?page=rss&c=1_2&f=0"
    echo "ğŸ” Fetching anime torrents from Nyaa.si..."
    echo "ğŸ“¡ RSS Feed: $rss_url"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    
    # AWK script for parsing and sorting RSS feed
    local awk_script='
    BEGIN { 
        RS = "<item>"; 
        FS = "\n"; 
        count = 0;
    }
    NR > 1 { 
        title = ""; pubDate = ""; link = ""; id = "";
        for (i=1; i<=NF; i++) {
            if ($i ~ /<title>/) {
                gsub(/<title>|<\/title>/, "", $i);
                title = $i;
            }
            else if ($i ~ /<pubDate>/) {
                gsub(/<pubDate>|<\/pubDate>/, "", $i);
                pubDate = $i;
            }
            else if ($i ~ /<link>https:\/\/nyaa.si\/download\//) {
                gsub(/<link>https:\/\/nyaa.si\/download\/|\.torrent<\/link>/, "", $i);
                id = $i;
            }
        }
        
        if (title != "" && pubDate != "" && id != "") {
            count++;
            if (count <= 15) {
                entry = sprintf("\033[1;36m%s\033[0m\n\033[1;33m%s\033[0m\nID: \033[1;32m%s\033[0m\n\n", 
                    pubDate, title, id);
                entries[count] = entry;
                dates[count] = pubDate;
            }
        }
    }
    END {
        # Sort entries by date (most recent first)
        for (i = 1; i <= count; i++) {
            for (j = i + 1; j <= count; j++) {
                if (dates[i] < dates[j]) {
                    # Swap dates and entries
                    temp = dates[i]; dates[i] = dates[j]; dates[j] = temp;
                    temp = entries[i]; entries[i] = entries[j]; entries[j] = temp;
                }
            }
        }
        
        # Print sorted entries
        for (i = 1; i <= count; i++) {
            printf("%s", entries[i]);
        }
    }'
    
    # Parse and display the results
    fetch_url "$rss_url" | awk "$awk_script"
    
    # Prompt for download
    prompt_download
}

# Function to search for a specific anime - optimized version
search_anime() {
    local search_term="$1"
    local quality="${2:-1080p}"
    
    if [[ -z "$search_term" ]]; then
        echo "Please provide a search term."
        echo "Usage: search_anime [anime_name] [quality]"
        return 1
    fi
    
    echo "ğŸ” Searching for \"$search_term\" in $quality quality..."
    
    # First try with NO fansub filter (show all fansubs)
    # Note: Empty string as 3rd parameter means "no filter"
    if anime_torrents "$search_term" "$quality" "" 15; then
        return 0
    fi
    
    # If no results found with quality filter, try without quality filter
    echo "No results found with quality filter. Trying without quality filter..."
    if anime_torrents "$search_term" "" "" 15; then
        return 0
    fi
    
    # If still no results, try with common misspellings or alternative names
    echo "No results found. Would you like to try with a different search term? (y/n)"
    read -r -k 1 try_different
    echo ""
    
    if [[ "$try_different" =~ [yY] ]]; then
        echo "Enter alternative anime name:"
        read -r alt_name
        search_anime "$alt_name" "$quality"
    else
        echo "No anime torrents found matching your criteria."
        return 1
    fi
}

# Function to search by specific fansub group
search_by_fansub() {
    local search_term="$1"
    local quality="${2:-1080p}"
    
    if [[ -z "$search_term" ]]; then
        echo "Please provide a search term."
        echo "Usage: search_by_fansub [anime_name] [quality]"
        return 1
    fi
    
    echo "Select a fansub group:"
    echo "1) SubsPlease"
    echo "2) Erai-raws"
    echo "3) DameDesuYo"
    echo "4) Other (specify)"
    read -r -k 1 fansub_choice
    echo ""
    
    local fansub=""
    case $fansub_choice in
        1) fansub="SubsPlease" ;;
        2) fansub="Erai-raws" ;;
        3) fansub="DameDesuYo" ;;
        4) 
            echo "Enter fansub name:"
            read -r fansub
            ;;
        *) fansub="SubsPlease" ;;
    esac
    
    echo "ğŸ” Searching for \"$search_term\" in $quality quality from $fansub..."
    anime_torrents "$search_term" "$quality" "$fansub" 15
}

# Function to set up qBittorrent RSS feeds
setup_rss() {
    local anime_name="$1"
    local quality="${2:-1080p}"
    local fansub="${3:-SubsPlease}"
    
    if [[ -z "$anime_name" ]]; then
        echo "Please provide an anime name."
        echo "Usage: setup_rss [anime_name] [quality] [fansub]"
        return 1
    fi
    
    echo "ğŸ”„ Setting up RSS feed for $anime_name ($quality, $fansub)"
    echo "This will help qBittorrent automatically download new episodes."
    echo ""
    echo "Steps to set up in qBittorrent:"
    echo "1. Open qBittorrent"
    echo "2. Go to View > RSS Reader"
    echo "3. Click 'New subscription' and add: https://nyaa.si/?page=rss&c=1_2&f=0"
    echo "4. Click 'RSS Downloader' button on the right"
    echo "5. Create a new rule named: $anime_name"
    echo "6. In 'Must contain', add: $fansub $anime_name $quality"
    echo "7. Set download folder to: $ANIME_DOWNLOAD_DIR"
    echo ""
    echo "For SubsPlease specifically, you can use this direct RSS URL:"
    echo "https://subsplease.org/rss/?t&r=${quality/p/}"
    echo ""
    
    echo "Would you like to open qBittorrent now? (y/n)"
    read -r -k 1 open_choice
    echo ""
    
    if [[ "$open_choice" =~ [yY] ]] && command -v qbittorrent &> /dev/null; then
        qbittorrent &
    elif [[ "$open_choice" =~ [yY] ]]; then
        echo "Error: qBittorrent is not installed or not in your PATH."
    fi
}

# Function to list seasonal anime
seasonal_anime() {
    echo "ğŸŒ¸ Current Season Anime"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    
    # Get current season information
    local current_month=$(date +%m)
    local current_year=$(date +%Y)
    local season=""
    
    # Determine current season
    if [[ $current_month -ge 1 && $current_month -le 3 ]]; then
        season="WINTER"
    elif [[ $current_month -ge 4 && $current_month -le 6 ]]; then
        season="SPRING"
    elif [[ $current_month -ge 7 && $current_month -le 9 ]]; then
        season="SUMMER"
    else
        season="FALL"
    fi
    
    echo "ğŸ“… Season: $season $current_year"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    
    # Search for popular anime this season on Nyaa
    # Using SubsPlease as they typically have seasonal shows
    anime_torrents "" "1080p" "SubsPlease" 15
    
    echo "Do you want to search for a specific anime from this season? (y/n)"
    read -r -k 1 search_choice
    echo ""
    
    if [[ "$search_choice" =~ [yY] ]]; then
        echo "Enter the anime name:"
        read -r anime_name
        search_anime "$anime_name"
    fi
}

# Function to display help information
anime_help() {
    cat << 'EOF'
ğŸ® Anime Torrent Downloader - Help
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Commands:
  anime [anime_name] [quality]  - Search for anime torrents (all fansubs)
  fansub [anime_name] [quality] - Search by specific fansub group
  latest                        - Show latest anime releases
  seasonal                      - Show current season anime
  setup_rss [anime_name]        - Set up automatic downloads

Examples:
  anime "One Piece" 720p       - Search for One Piece in 720p
  anime "Jujutsu Kaisen"       - Search for Jujutsu Kaisen in 1080p
  fansub "Demon Slayer"        - Search with specific fansub options
  setup_rss "Demon Slayer"     - Set up RSS for Demon Slayer

Tips:
  - Quality options: 1080p, 720p, 480p
  - Fansub options: SubsPlease, Erai-raws, DameDesuYo, etc.
  - SubsPlease releases new episodes fastest
  - Use magnet links for faster downloads
  - All downloads go to: $ANIME_DOWNLOAD_DIR
EOF
}

# Command aliases for easy access
alias nyaa='anime_torrents'
alias anime='search_anime'
alias fansub='search_by_fansub'
alias latest='latest_anime'
alias seasonal='seasonal_anime'
alias rss='setup_rss'
alias animehelp='anime_help'


# Enhanced TorrentBD function with multiple download support - FIXED
torrentbd_news() {
  local rss_url="<TorrentBD RSS URL>"
  local temp_file=$(mktemp)
  local details_dir=$(mktemp -d)
  local download_dir="$HOME/Videos"

  # Make sure download directory exists
  mkdir -p "$download_dir"

  # Fetch RSS feed
  echo "Fetching latest torrents from TorrentBD..."
  curl -s "$rss_url" > "$temp_file"

  if [[ $? -ne 0 ]]; then
    echo "Failed to fetch RSS feed. Check your internet connection."
    rm -f "$temp_file"
    rmdir "$details_dir" 2>/dev/null
    return 1
  fi

  # Process and extract data from RSS (same as before)
  local count=1
  local display_list="${details_dir}/display.txt"
  touch "$display_list"

  grep -A20 "<item>" "$temp_file" | tr -d '\n' | sed 's/<item>/\n<item>/g' | grep "<item>" | while read -r item; do
    local title=$(echo "$item" | grep -o '<title>.*</title>' | sed 's/<title>\(.*\)<\/title>/\1/' | sed 's/&amp;/\&/g' | sed 's/&#039;/'"'"'/g')
    [[ "$title" == "TorrentBD" ]] && continue

    local link=$(echo "$item" | grep -o '<link>.*</link>' | sed 's/<link>\(.*\)<\/link>/\1/' | sed 's/&amp;/\&/g')
    local category=$(echo "$item" | grep -o '<category>.*</category>' | sed 's/<category>\(.*\)<\/category>/\1/' | sed 's/^ *//' | sed 's/ *$//')
    local description=$(echo "$item" | grep -o '<description>.*</description>' | sed 's/<description>\(.*\)<\/description>/\1/')
    local pubdate=$(echo "$item" | grep -o '<pubDate>.*</pubDate>' | sed 's/<pubDate>\(.*\)<\/pubDate>/\1/')
    local date=$(echo "$pubdate" | awk '{print $1, $2, $3, $4}' | sed 's/,//g')
    local size=$(echo "$description" | grep -o 'Size: [^ ]* [^ ]*' | sed 's/Size: //')
    [[ -z "$size" ]] && size="N/A"
    local seeders=$(echo "$description" | grep -o 'Seeders: [0-9]*' | sed 's/Seeders: //')
    [[ -z "$seeders" ]] && seeders="0"
    local leechers=$(echo "$description" | grep -o 'Leechers: [0-9]*' | sed 's/Leechers: //')
    [[ -z "$leechers" ]] && leechers="0"

    local simple_title=$(echo "$title" | sed -E 's/([0-9]{3,4}p|WEB-DL|BluRay|WEBRip|x264|x265|AAC|DD|AC3|DDP|DTS|HEVC|REMUX|HDR|SDR|REMASTERED|AV1|10bit|AMZN|DSNP|NF|HULU|IMAX|DUBBED|DUAL|PROPER|REPACK|EXTENDED|UNCUT|UNRATED|CRITERION|FLAC).*//')
    if [[ "$simple_title" == *"S0"* && "$simple_title" == *"E0"* ]]; then
      simple_title=$(echo "$simple_title" | sed -E 's/(S[0-9]+E[0-9]+).*/\1/')
    fi
    simple_title=$(echo "$simple_title" | sed 's/ *$//')

    echo "$title" > "${details_dir}/${count}.title"
    echo "$category" > "${details_dir}/${count}.category"
    echo "$size" > "${details_dir}/${count}.size"
    echo "$seeders" > "${details_dir}/${count}.seeders"
    echo "$leechers" > "${details_dir}/${count}.leechers"
    echo "$date" > "${details_dir}/${count}.date"
    echo "$link" > "${details_dir}/${count}.link"

    printf "%-3s %s\n" "${count}." "${simple_title}" >> "$display_list"
    ((count++))
  done

  if [[ ! -s "$display_list" ]]; then
    echo "No torrents found in the RSS feed."
    rm -f "$temp_file"
    rm -rf "$details_dir"
    return 0
  fi

  # Create enhanced preview script
  cat > "${details_dir}/preview.sh" << 'EOF'
#!/bin/bash
line="$1"
details_dir="$2"

idx=$(echo "$line" | awk '{print $1}' | sed 's/\.//')

if [[ -f "${details_dir}/${idx}.title" ]]; then
  title=$(cat "${details_dir}/${idx}.title")
  category=$(cat "${details_dir}/${idx}.category")
  size=$(cat "${details_dir}/${idx}.size")
  seeders=$(cat "${details_dir}/${idx}.seeders")
  leechers=$(cat "${details_dir}/${idx}.leechers")
  date=$(cat "${details_dir}/${idx}.date")

  echo -e "\033[1;36m=== TORRENT DETAILS ===\033[0m"
  echo -e "\033[1;33mTitle:\033[0m $title"
  echo -e "\033[1;33mCategory:\033[0m $category"
  echo -e "\033[1;33mSize:\033[0m $size"
  echo -e "\033[1;33mSeeders:\033[0m $seeders"
  echo -e "\033[1;33mLeechers:\033[0m $leechers"
  echo -e "\033[1;33mDate:\033[0m $date"
  echo ""
  echo -e "\033[1;32mâ–¶ Press Enter to download\033[0m"
  echo -e "\033[1;34mâ–¶ Press Ctrl+C to go back\033[0m"
else
  echo -e "\033[1;31mDetails not found for item $idx\033[0m"
fi
EOF
  chmod +x "${details_dir}/preview.sh"

  # Main download loop
  while true; do
    local fzf_header="TorrentBD - Enter: Download | Tab: Multi-select | Esc: Quit | Ctrl+R: Refresh"
    local selected_lines=$(cat "$display_list" | \
      fzf --height=80% \
          --layout=reverse \
          --border=rounded \
          --header="$fzf_header" \
          --preview="${details_dir}/preview.sh {} ${details_dir}" \
          --preview-window=right:50%:wrap \
          --prompt="Select torrent(s) > " \
          --pointer="â–¶" \
          --marker="âœ“" \
          --multi \
          --bind='ctrl-r:reload(cat '"$display_list"')')

    # If user cancelled selection
    if [[ -z "$selected_lines" ]]; then
      echo "Exiting TorrentBD..."
      break
    fi

    # Process each selected torrent
    local download_count=0
    while IFS= read -r selected_line; do
      [[ -z "$selected_line" ]] && continue

      local choice=$(echo "$selected_line" | awk '{print $1}' | sed 's/\.//')

      if [[ -f "${details_dir}/${choice}.title" && -f "${details_dir}/${choice}.link" ]]; then
        local title=$(cat "${details_dir}/${choice}.title")
        local link=$(cat "${details_dir}/${choice}.link")
        local safe_title=$(echo "$title" | sed 's/[<>:"|?*]/_/g')
        local torrent_filename="${download_dir}/${safe_title// /_}.torrent"

        echo "[$((download_count + 1))] Downloading: $title"
        curl -s -L "$link" -o "$torrent_filename"

        if [[ $? -eq 0 ]]; then
          echo "âœ“ Saved: $(basename "$torrent_filename")"
          ((download_count++))
        else
          echo "âœ— Failed to download: $title"
        fi
      fi
    done <<< "$selected_lines"

    if [[ $download_count -gt 0 ]]; then
      echo ""
      echo "Downloaded $download_count torrent file(s) to: $download_dir"

      # Ask if user wants to open qBittorrent - FIXED VERSION
      echo ""
      printf "Open qBittorrent now? (y/N): "
      read -r qbt_reply < /dev/tty
      if [[ "$qbt_reply" =~ ^[Yy]$ ]]; then
        if command -v qbittorrent >/dev/null 2>&1; then
          echo "Opening qBittorrent..."
          qbittorrent >/dev/null 2>&1 &
          disown
        else
          echo "qBittorrent not found. Please install it or manually open the torrent files."
        fi
      fi
    fi

    # Ask if user wants to continue - FIXED VERSION
    echo ""
    printf "Download more torrents? (Y/n): "
    read -r continue_reply < /dev/tty
    if [[ "$continue_reply" =~ ^[Nn]$ ]]; then
      break
    fi
  done

  # Clean up
  rm -f "$temp_file"
  rm -rf "$details_dir"
  echo "Session ended. Happy downloading! ğŸ´â€â˜ ï¸"
}

alias tbd="torrentbd_news"


#export PATH="$PATH:$HOME/Github/metasploit-framework"
export PATH=$HOME/.local/bin:$PATH
export PATH=$HOME/.cargo/bin:$PATH
export GOBIN=`go env GOPATH`/bin
export PATH=$PATH:$GOBIN
#alias msfconsole="pushd $HOME/Github/metasploit-framework && ./msfconsole && popd"
export VISUAL=nano
export EDITOR=nano
if [ -f /usr/bin/fastfetch ]; then
    fastfetch
fi
eval "$(oh-my-posh init zsh --config $HOME/Github/fun007/configs/illusi0n_mod.omp.json)"
